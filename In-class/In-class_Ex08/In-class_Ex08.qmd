---
title: "Geographic Accessibility"
author: "Federico Jose Rodriguez"
date: "Oct 28 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  message: false
  freeze: true
---

We revise the hands-on exercise and look at the calibration in a bit more detail.

# Getting Started

## Data Sources

The data for this exercise comes in the form of four files:

-   2014 Master Plan Planning subzone boundary in shapefile format sourced from data.gov.sg

-   Singapore GIS data with hexagons of 250m radius generated by using `st_make_grid()` of the **sf** package

-   Location of eldercare centres sourced from data.gov.sg and in shapefile format

-   A distance matrix in csv format from the hexagons to the eldercare centres. The data also contains fields for the entry, exit and network costs which give the distance between roads and the hexagon, between roads and eldercare centres, and between the network points of the hexagon and eldercare centre.

Aside from the first dataset, the balance are already processed datasets c/o Prof Kam to be used by his students for this exercise.

## Installing and launching R packages

This exercise will load the same R packages. The package **ggstatsplot** will also be used more in this in-class exercise.

The code chunk below uses `p_load()` of **pacman** package to check if the packages are installed in the computer. It installs them first if they are not. It then loads them into R.

```{r}
pacman::p_load(tmap, SpatialAcc, sf, 
               ggstatsplot, reshape2,
               tidyverse)
```

# Geospatial Data Wrangling

## Importing geospatial data

We use `st_read()` of sf package to load the three geospatial datasets into R.

::: panel-tabset
#### Loading Planning Subzone

```{r}
mpsz <- st_read(dsn = "data/geospatial", layer = "MP14_SUBZONE_NO_SEA_PL")
```

#### Loading Hexagons

```{r}
hexagons <- st_read(dsn = "data/geospatial", layer = "hexagons") 
```

#### Loading Eldercare Centre Location

```{r}
eldercare <- st_read(dsn = "data/geospatial", layer = "ELDERCARE") 
```
:::

The outputs show that all the objects are in **sf** format. The object `mpsz` is both in multipolygon class and currently does not have EPSG information.

## Updating CRS information

The code chunk below assigns and ensures that all objects have the same EPSG code of 3414.

```{r}
mpsz <- st_transform(mpsz, 3414)
eldercare <- st_transform(eldercare, 3414)
hexagons <- st_transform(hexagons, 3414)
```

## Cleaning and updating attribute fields of the geospatial data

If we inspect the last two objects, we see that there are a number of redundant or unnecessary fields. We use the code chunk below to only keep the necessary ones using `select()`. We also add a new field called capacity to both objects using `mutate()`.

```{r}
eldercare <- eldercare %>%
  select(fid, ADDRESSPOS) %>%
  mutate(capacity = 100)

hexagons <- hexagons %>%
  select(fid) %>%
  mutate(demand = 100)
```

For this exercise we use a dummy value of 100 for the capacity, but, in practice, this number needs to be updated with the actual capacity of the location.


# Aspatial Data Handling and Wrangling

## Importing the Distance Matrix

The code chunk below uses `read_csv()` to load the distance matrix into R

```{r}
ODMatrix <- read_csv("data/aspatial/OD_Matrix.csv", skip = 0)
```
The data is already preprocessed, but if one wants to generate the distances themselves, they may use the package r5r.

We can inspect the object using `head()`

```{r}
head(ODMatrix)
```

## Tidying the distance matrix

Based on our inspection, we see that the distance matrix is not yet in the typical matrix format where the origin is on one axis and the destination is on another. Instead, the origins and the destinations are in their respective columns and there are fields for the distances.

In order to transform the object into matrix format, we use `spread()` of **tidyr** in the code chunk below. `pivot_wider()` can also be used to achieve the same result

```{r}
distmat <- ODMatrix %>%
  select(origin_id, destination_id, total_cost) %>%
  spread(destination_id, total_cost)%>%
  select(c(-c('origin_id')))
```

```{r}
class(distmat)
```

The matrix is still in dataframe format and is in meters. We use the code below to convert it to km and turn it into a matrix.

```{r}
distmat_km <- as.matrix(distmat/1000)
```

```{r}
class(distmat_km)
```





# Modelling and Visualizing Accessibility using Hansen Method

## Computing Hansen Accessibility

To compute for the Hansen accessibility we use `ac()` of the **SpatialAcc** package. The code chunk below does this and also uses `data.frame()` to convert the output into dataframe format.

```{r}
acc_Hansen <- data.frame(ac(hexagons$demand,
                            eldercare$capacity,
                            distmat_km, 
                            #d0 = 50,
                            power = 2, 
                            family = "Hansen"))
```

```{r}
glimpse(acc_Hansen)
```

We see that the function returns one field and its default field name is a unreadable. We can fix this by assigning a new name to `colnames()`

```{r}
colnames(acc_Hansen) <- "accHansen"
```

```{r}
glimpse(acc_Hansen)
```

We then convert the accessibility measure to tibble format and then bind it with the hexagon data frame using the two lines of code in the following code chunk

```{r}
acc_Hansen <- tibble::as_tibble(acc_Hansen)

hexagon_Hansen <- bind_cols(hexagons, acc_Hansen)
```

## Visualising Hansen's Accessibility

We first extract the extent of the `hexagons` object using `st_bbox()` of sf package

```{r}
mapex <- st_bbox(hexagons)
```

We use **tmap** package in the code chunk below to create a visualization of the accessibility of eldercare centres across Singapore using Hansen method.

```{r}
tmap_mode("plot")
tm_shape(hexagon_Hansen,
         bbox = mapex) + 
  tm_fill(col = "accHansen",
          n = 10,
          style = "quantile",
          border.col = "black",
          border.lwd = 1) +
tm_shape(eldercare) +
  tm_symbols(size = 0.1) +
  tm_layout(main.title = "Accessibility to eldercare: Hansen method",
            main.title.position = "center",
            main.title.size = 2,
            legend.outside = FALSE,
            legend.height = 0.45, 
            legend.width = 3.0,
            legend.format = list(digits = 6),
            legend.position = c("right", "top"),
            frame = TRUE) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.5)
```

## Statistical graphical representation

We can compare the distribution of the accessibility values (using Hansen method) across planning regions.

First, we need to include the planning region field into `hexagon_Hansen` object by using `st_join()` in the code chunk below.

```{r}
hexagon_Hansen <- st_join(hexagon_Hansen, mpsz, 
                          join = st_intersects)
```

We then use `ggbetweenstats()` to produce a more analytic statistical visual.

```{r}
ggbetweenstats(data = hexagon_Hansen,
               x= REGION_N,
               y = accHansen,
               type = "p")
```

