---
title: "First Order Spatial Points Analysis Methods"
author: "Federico Jose Rodriguez"
date: "Aug 28 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  message: false
  freeze: true
---

For this hands-on exercise, we start learning about Spatial Point pattern analysis, starting with First Order effects. (based on an underlying property or location)

We will be using the functions of the **spatstat** package, and applying it to an analysis on the location of childcare centres in Singapore.

This exercise is based on Chapter 4 of Dr Kam's online book which can be accessed [here](https://r4gdsa.netlify.app/ "R for Geospatial Data Science and Analytics by Dr Kam").

# Getting Started

## Data Sources

Data for this exercise are from public sources and include:

-   Location and attribute information of childcare centres in Singapore from data.gov.sg

-   Master Plan 2014 Subzone Boundary from [data.gov.sg](https://beta.data.gov.sg/datasets/d_d14da225fccf921049ab64238ff473d9/view)

-   National boundary of Singapore provided in SLA and ESRI shapefile format

## Installing and launching R packages

This exercise will make use of five R packages: **sf**, **tidyverse, spatstat, raster, maptools** and **tmap**. Among these, the new ones we are using are:

-   **spatstat** - offers a wide range of functions for point pattern analysis (PPA)

-   **raster** - used to read, write, manipulate and analyse models of gridded spatial data

The code chunk below uses `p_load()` of **pacman** package to check if the packages are installed in the computer. It installs them first if they are not. It then loads them into R.

```{r}
pacman::p_load(sf, tidyverse, tmap, spatstat, raster)
```

# Data Loading and Preparation

## Importing the Geospatial Data

We use the `st_read()` function of the **sf** package to load the different geospatial datasets into R.

The code below loads the preschool location geoJSON file into the dataframe `childcare_sf` and projects it into SVY21.

```{r}
childcare_sf <- st_read("data/geospatial/child-care-services-geojson.geojson") %>%
  st_transform(crs = 3414)
```

The code chunk below loads the Singapore National boundary shapefile into the dataframe `sg_sf`.

```{r}
sg_sf <- st_read(dsn = "data/geospatial", layer="CostalOutline")
```

The code chunk below loads the Master Plan 2014 subzone boundary shapefile into another dataframe called mpsz_sf

```{r}
mpsz_sf <- st_read(dsn = "data/geospatial", 
                layer = "MP14_SUBZONE_WEB_PL")
```

We can use st_crs() to check what coordinate systems are used in each of the three sf dataframes.

`childcare_sf` is in SVY21 using EPSG code 3414 after our load and transform operation above.

```{r}
st_crs(childcare_sf)
```

While `sg_sf` and `mpsz_sf` appeared to be in SVY21, running `st_crs()` reveals that they are not using the correct EPSG code.

```{r}
st_crs(sg_sf)
```

```{r}
st_crs(mpsz_sf)
```

Using `st_set_crs()` we can convert these and correct the crs information.

```{r}
sg_sf = st_set_crs(sg_sf, 3414)
mpsz_sf = st_set_crs(mpsz_sf, 3414)
```

Rerunning `st_crs()` shows that the correct EPSG code is now reflected.

```{r}
st_crs(mpsz_sf)
```

## Mapping the Geospatial Data Sets

With all three datasets in the same coordinate system, we can draw them in a single map as different layers using `tm_shape()` as in the following code chunk. See how the planning subzones extend beyond the defined coastal borders.

```{r}
tm_shape(sg_sf)+
    tm_fill("lightblue") +
    tm_borders(lwd = 0.1,  alpha = 1)+
    tm_shape(mpsz_sf) +
    tm_fill("grey", alpha = 0.5) +
    tm_borders(lwd = 0.1,  alpha = 1) +
    tm_shape(childcare_sf) +
    tm_dots(col = "darkgreen")
```

The previous map shows the importance of using the same reference system across three different data sets for mapping and for analysis.

Alternatively, we can prepare a pin map using the code below which switches to interactive mode using `tmap_mode()`

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

Interactive maps allow the user to navigate and zoom in and out of the map freely. Features can also be queried by clicking on them. The background map layer is defaulted to ESRI.WorldGrayCanvas. There are two other available background map layers (ESRI.WorldToolMap and OpenStreetMap)

It is important to switch back to static mode (using the code below) when interactive maps are not required. This is as each interactive map uses a connection. The use of of interactive maps should be limited when publishing.

```{r}
tmap_mode('plot')
```

# Spatial Data Wrangling

While **sf** is gaining popularity, some geospatial analysis require that the input data is in **sp**'s spatial class. It is therefore important to learn about converting an dataframe from sf to sp.

## Converting sf dataframe sp spatial class

The code chunk below converts the three dataframes using `as_Spatial()` from the **sf** package.

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

We can check the contents of the new dataframes by calling them. This confirms that they are in the spatial\* class format.

```{r}
childcare
```

## Converting the spatial class to generic sp format

**spatstat** requires that the data is in ***ppp*** object form. There is no direct way to do this from spatial\* class. We need to convert spatial\* class to a spatial object first.

The code chunk below transform two of the spatial\* objects into generic sp objects.

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

Calling `childcare_sp` and `sg_sp` lets us check their properties.

```{r}
childcare_sp
```

```{r}
sg_sp
```

## Converting generic sp format into spatstat's ppp format

We will then use `as.ppp()` from **spatstat** package to convert the (spatial) data into spatstat's ppp object format.

```{r}
childcare_ppp <- as.ppp(childcare_sf)
childcare_ppp
```

We see the difference of this format when we use `plot()` (from R Graphics) to produce a quick map of the data.

```{r}
plot(childcare_ppp)
```

We can see summary information on the new ppp object using the code chunk below.

```{r}
summary(childcare_ppp)
```

## Handling duplicated points

We can check duplication in a ppp object using the code chunk below.

```{r}
any(duplicated(childcare_ppp))
```

To count the number of coincident points, we can use the `multiplicity()` function.

```{r}
multiplicity(childcare_ppp)
```

We can wrap this in `sum()` to count the number of locations with more than one event.

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

The outputs show that there are no duplication in `childcare_ppp`

If there are any duplicates, there are three possible approaches to handle them:

1.  **Delete the duplicates.** The downside of this is that some (useful) information will be lost

2.  **Jittering**. Adding a small perturbation to the duplicate points so they do not occupy the exact same space

3.  **Make each point unique**, then attach the duplicates of the points as marks or attributes to the point

The code chunk below shows how jittering can be applied using `rjitter()`

```{r}
#| eval: false
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

## Creating owin object

When analysing spatial point patterns, it is best to confine the analysis within a geographical area. In **spatstat**, the object that represents the bounded region is called an **owin**.

The code chunk below creates an **owin** based on the `sg` SpatialPolygon object.

```{r}
sg_owin <- as.owin(sg_sf)
```

The owin object can be displayed graphically using `plot()` and summarized using `summary()`

```{r}
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

## Combining point events object and owin object

In this last step,
