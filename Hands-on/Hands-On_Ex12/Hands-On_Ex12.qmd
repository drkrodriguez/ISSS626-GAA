---
title: "Modelling Geographic Accessibility"
author: "Federico Jose Rodriguez"
date: "Oct 27 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  message: false
  freeze: true
---

In this hands-on exercise, we model geographic accessibility using R.

This exercise is based on Chapter 17 of Dr Kam's online book which can be accessed [here](https://r4gdsa.netlify.app/ "R for Geospatial Data Science and Analytics by Dr Kam").

# Getting Started

## Data Sources

The data for this exercise comes in the form of four files:

-   2014 Master Plan Planning subzone boundary in shapefile format sourced from data.gov.sg

-   Singapore GIS data with hexagons of 250m radius generated by using `st_make_grid()` of the **sf** package

-   Location of eldercare centres sourced from data.gov.sg and in shapefile format

-   A distance matrix in csv format from the hexagons to the eldercare centres. The data also contains fields for the entry, exit and network costs which give the distance between roads and the hexagon, between roads and eldercare centres, and between the network points of the hexagon and eldercare centre.

Aside from the first dataset, the balance are already processed datasets c/o Prof Kam to be used by his students for this exercise.

## Installing and launching R packages

This exercise will make use of six R packages. For this exercise, we will use **spatialAcc** which is used to model geographic accessibility.

The code chunk below uses `p_load()` of **pacman** package to check if the packages are installed in the computer. It installs them first if they are not. It then loads them into R.

```{r}
pacman::p_load(tmap, SpatialAcc, sf, 
               ggstatsplot, reshape2,
               tidyverse)
```

# Geospatial Data Wrangling

## Importing geospatial data

We use `st_read()` of sf package to load the three geospatial datasets into R.

::: panel-tabset
#### Loading Planning Subzone

```{r}
mpsz <- st_read(dsn = "data/geospatial", layer = "MP14_SUBZONE_NO_SEA_PL")
```

#### Loading Hexagons

```{r}
hexagons <- st_read(dsn = "data/geospatial", layer = "hexagons") 
```

#### Loading Eldercare Centre Location

```{r}
eldercare <- st_read(dsn = "data/geospatial", layer = "ELDERCARE") 
```
:::

The outputs show that all the objects are in **sf** format. The object `mpsz` is both in multipolygon class and currently does not have EPSG information.

## Updating CRS information

The code chunk below assigns and ensures that all objects have the same EPSG code of 3414.

```{r}
mpsz <- st_transform(mpsz, 3414)
eldercare <- st_transform(eldercare, 3414)
hexagons <- st_transform(hexagons, 3414)
```

We can then use `st_crs()` of sf package to confirm the CRS information of an object.

```{r}
st_crs(mpsz)
```

## Cleaning and updating attribute fields of the geospatial data

If we inspect the last two objects, we see that there are a number of redundant or unnecessary fields. We use the code chunk below to only keep the necessary ones using `select()`. We also add a new field called capacity to both objects using `mutate()`.

```{r}
eldercare <- eldercare %>%
  select(fid, ADDRESSPOS) %>%
  mutate(capacity = 100)

hexagons <- hexagons %>%
  select(fid) %>%
  mutate(demand = 100)
```

For this exercise we use a dummy value of 100 for the capacity, but, in practice, this number needs to be updated with the actual capacity of the location.

# Aspatial Data Handling and Wrangling

## Importing the Distance Matrix

The code chunk below uses `read_csv()` to load the distance matrix into R

```{r}
ODMatrix <- read_csv("data/aspatial/OD_Matrix.csv", skip = 0)
```

We can inspect the object using `head()`

```{r}
head(ODMatrix)
```

## Tidying the distance matrix

Based on our inspection, we see that the distance matrix is not yet in the typical matrix format where the origin is on one axis and the destination is on another. Instead, the origins and the destinations are in their respective columns and there are fields for the distances.

In order to transform the object into matrix format, we use `spread()` of **tidyr** in the code chunk below. `pivot_wider()` can also be used to achieve the same result

```{r}
distmat <- ODMatrix %>%
  select(origin_id, destination_id, total_cost) %>%
  spread(destination_id, total_cost)%>%
  select(c(-c('origin_id')))
```

```{r}
class(distmat)
```

The matrix is still in dataframe format and is in meters. We use the code below to convert it to km and turn it into a matrix.

```{r}
distmat_km <- as.matrix(distmat/1000)
```

```{r}
class(distmat_km)
```

# Modelling and Visualizing Accessibility using Hansen Method

## Computing Hansen Accessibility

To compute for the Hansen accessibility we use `ac()` of the **SpatialAcc** package. The code chunk below does this and also uses `data.frame()` to convert the output into dataframe format.

```{r}
acc_Hansen <- data.frame(ac(hexagons$demand,
                            eldercare$capacity,
                            distmat_km, 
                            #d0 = 50,
                            power = 2, 
                            family = "Hansen"))
```

```{r}
glimpse(acc_Hansen)
```

We see that the function returns one field and its default field name is a unreadable. We can fix this by assigning a new name to `colnames()`

```{r}
colnames(acc_Hansen) <- "accHansen"
```

```{r}
glimpse(acc_Hansen)
```

We then convert the accessibility measure to tibble format and then bind it with the hexagon data frame using the two lines of code in the following code chunk

```{r}
acc_Hansen <- tibble::as_tibble(acc_Hansen)

hexagon_Hansen <- bind_cols(hexagons, acc_Hansen)
```

## Visualising Hansen's Accessibility

We first extract the extent of the `hexagons` object using `st_bbox()` of sf package

```{r}
mapex <- st_bbox(hexagons)
```

We use **tmap** package in the code chunk below to create a visualization of the accessibility of eldercare centres across Singapore using Hansen method.

```{r}
tmap_mode("plot")
tm_shape(hexagon_Hansen,
         bbox = mapex) + 
  tm_fill(col = "accHansen",
          n = 10,
          style = "quantile",
          border.col = "black",
          border.lwd = 1) +
tm_shape(eldercare) +
  tm_symbols(size = 0.1) +
  tm_layout(main.title = "Accessibility to eldercare: Hansen method",
            main.title.position = "center",
            main.title.size = 2,
            legend.outside = FALSE,
            legend.height = 0.45, 
            legend.width = 3.0,
            legend.format = list(digits = 6),
            legend.position = c("right", "top"),
            frame = TRUE) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.5)
```

## Statistical graphical representation

We can compare the distribution of the accessibility values (using Hansen method) across planning regions.

First, we need to include the planning region field into `hexagon_Hansen` object by using `st_join()` in the code chunk below.

```{r}
hexagon_Hansen <- st_join(hexagon_Hansen, mpsz, 
                          join = st_intersects)
```

We then use `ggplot()` to produce a box plot of the accessibility value by planning region.

```{r}
ggplot(data=hexagon_Hansen, 
       aes(y = log(accHansen), 
           x= REGION_N)) +
  geom_boxplot() +
  geom_point(stat="summary", 
             fun.y="mean", 
             colour ="red", 
             size=2)
```

# Modelling and Visualizing Accessibility using KD2SFCA Method

## Computing KD2SFCA Accessibility

To compute for the KD2SFCA accessibility we use `ac()` of the **SpatialAcc** package. The code chunk below does this and also uses `data.frame()` to convert the output into dataframe format. Compared to the previous section, we use a different value for the family argument.

```{r}
acc_KD2SFCA <- data.frame(ac(hexagons$demand,
                            eldercare$capacity,
                            distmat_km, 
                            d0 = 50,
                            power = 2, 
                            family = "KD2SFCA"))

colnames(acc_KD2SFCA) <- "accKD2SFCA"
acc_KD2SFCA <- tibble::as_tibble(acc_KD2SFCA)
hexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)
```

```{r}
glimpse(acc_KD2SFCA)
```

The object already includes updating the measure's column name and binds the measure values to the hexagon sf dataframe.

## Visualising KD2SFCA's Accessibility

We again use **tmap** package in the code chunk below to create a visualization of the accessibility of eldercare centres across Singapore using KD2SFCA method.Note that we reuse the `mapex` object from the previous section.

```{r}
tmap_mode("plot")
tm_shape(hexagon_KD2SFCA,
         bbox = mapex) + 
  tm_fill(col = "accKD2SFCA",
          n = 10,
          style = "quantile",
          border.col = "black",
          border.lwd = 1) +
tm_shape(eldercare) +
  tm_symbols(size = 0.1) +
  tm_layout(main.title = "Accessibility to eldercare: KD2SFCA method",
            main.title.position = "center",
            main.title.size = 2,
            legend.outside = FALSE,
            legend.height = 0.45, 
            legend.width = 3.0,
            legend.format = list(digits = 6),
            legend.position = c("right", "top"),
            frame = TRUE) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.5)
```

## Statistical graphical representation

We can compare the distribution of the accessibility values (using Hansen method) across planning regions.

First, we need to include the planning region field into the last object by using `st_join()` in the code chunk below.

```{r}
hexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, 
                          join = st_intersects)
```

We then use `ggplot()` to produce a box plot of the accessibility value by planning region.

```{r}
ggplot(data=hexagon_KD2SFCA, 
       aes(y = accKD2SFCA, 
           x= REGION_N)) +
  geom_boxplot() +
  geom_point(stat="summary", 
             fun.y="mean", 
             colour ="red", 
             size=2)
```

# Modelling and Visualizing Accessibility using SAM Method

## Computing SAM's Accessibility

To compute for the SAM accessibility we use `ac()` of the **SpatialAcc** package. The code chunk below does this and also uses `data.frame()` to convert the output into dataframe format. Compared to the previous section, we use a different value for the family argument.

```{r}
acc_SAM <- data.frame(ac(hexagons$demand,
                         eldercare$capacity,
                         distmat_km, 
                         d0 = 50,
                         power = 2, 
                         family = "SAM"))

colnames(acc_SAM) <- "accSAM"
acc_SAM <- tibble::as_tibble(acc_SAM)
hexagon_SAM <- bind_cols(hexagons, acc_SAM)
```

```{r}
glimpse(acc_SAM)
```

The object already includes updating the measure's column name and binds the measure values to the hexagon sf dataframe.

## Visualising SAM's Accessibility

We again use **tmap** package in the code chunk below to create a visualization of the accessibility of eldercare centres across Singapore using SAM method. Note that we reuse the `mapex` object from the previous section.

```{r}
tmap_mode("plot")
tm_shape(hexagon_SAM,
         bbox = mapex) + 
  tm_fill(col = "accSAM",
          n = 10,
          style = "quantile",
          border.col = "black",
          border.lwd = 1) +
tm_shape(eldercare) +
  tm_symbols(size = 0.1) +
  tm_layout(main.title = "Accessibility to eldercare: SAM method",
            main.title.position = "center",
            main.title.size = 2,
            legend.outside = FALSE,
            legend.height = 0.45, 
            legend.width = 3.0,
            legend.format = list(digits = 3),
            legend.position = c("right", "top"),
            frame = TRUE) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.5)
```

## Statistical graphical representation

We can compare the distribution of the accessibility values (using Hansen method) across planning regions.

First, we need to include the planning region field into the last object by using `st_join()` in the code chunk below.

```{r}
hexagon_SAM <- st_join(hexagon_SAM, mpsz, 
                       join = st_intersects)
```

We then use `ggplot()` to produce a box plot of the accessibility value by planning region.

```{r}
ggplot(data=hexagon_SAM, 
       aes(y = accSAM, 
           x= REGION_N)) +
  geom_boxplot() +
  geom_point(stat="summary", 
             fun.y="mean", 
             colour ="red", 
             size=2)
```

The boxes are not clear due to the outliers. Note that we can hide outliers in ggplot boxplots using the `outlier.shape` argument. In addition, the y-axis needs to be reset using `coord_cartesian()` as removing the outliers does not aautomatically adjust the axis.

```{r}
ggplot(data=hexagon_SAM, 
       aes(y = accSAM, 
           x= REGION_N)) +
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(ylim = c(0,8)) + 
  geom_point(stat="summary", 
             fun.y="mean", 
             colour ="red", 
             size=2)
```
