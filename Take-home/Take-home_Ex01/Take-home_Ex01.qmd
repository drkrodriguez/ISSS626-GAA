---
title: "Geospatial Analysis for Public Good: A Data-driven Perspective on Road Traffic Accidents in the Bangkok Metropolitan Region"
author: "Federico Jose Rodriguez"
date: "Sep 8 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  message: false
  freeze: true
---

(Summary here. WIP)

# A. Getting Started

## A.1 Background

Road traffic accidents account for 1.19million deaths and up to 50 million non-fatal injuries according to a [report by the WHO](https://www.who.int/news-room/fact-sheets/detail/road-traffic-injuries) last year.

The same report identifies major risk groups: low- and middle-income countries, (esp in Africa and Europe) the working population, and males. It also identifies some key risk factors which include human error, speeding, driving under the influence of alcohol, distracted driving, unsafe road infrastructure, unsafe vehicles, and law enforcement. Most of the factors identified are behavioral in nature but do not discount that other factors may also contribute to a higher risk of occurrence.

Within Southeast Asia, Thailand has ranked the highest in terms of incidence of road traffic accidents with an average number of of 20,000 deaths a year or 56 a day. The country has also seen an increase in the number of accidents from 2014 to 2021. A large 19% of these accidents occurred in national highways, and the chances of encountering an accident-prone zone was found to be 66%.

## A.2 Objectives

This study aims to take a deeper look into the road accidents in Thailand, focusing on the [Bangkok Metropolitan Region (BMR)](https://en.wikipedia.org/wiki/Bangkok_Metropolitan_Region) which contains the capital Bangkok, and five neighboring provinces. (Nonthaburi, Nakhon Pathom, Pathum Thani, Samut Prakan, Samut Sakhon)

As most literature has focused on behavioral and environmental factors, the study will focus on identifying spatiotemporal factors influencing the occurrence of road accidents in BMR. At the minimum, the study deliverables include the following:

-   Visualization of spatiotemporal dynamics of road traffic accidents in BMR

-   Detailed spatial analysis of road traffic accidents in BMR

-   Detailed spatiotemporal analysis of road traffic accidents in BMR

The appropriate technique must be used for these deliverables and all the analysis and visualizations will be carried out using R.

## A.3 Data Sources

The study makes use of the following datasets which are publicly available online.

| Dataset Short Name | Description                                               | Datasource                                                                              |
|------------------|----------------------|--------------------------------|
| THRA               | Thailand road accident data from 2019 to 2022             | [Kaggle](https://www.kaggle.com/datasets/thaweewatboy/thailand-road-accident-2019-2022) |
| THOSM              | Thailand roads open street map in shapefile format        | [HDX](https://data.humdata.org/dataset/hotosm_tha_roads)                                |
| THSAB              | Thailand - Subnational Administrative Boudaries shapefile | [HDX](https://data.humdata.org/dataset/cod-ab-tha?)                                     |
|                    |                                                           |                                                                                         |

## A.4 Importing and Launching R Packages

For this study, four R packages will be used. A description of the packages and the code, using `p_load()` of the **pacman** package, to import them is given below.

::: panel-tabset
#### Package Description

The loaded packages include:

-   **sf -** package for importing, managing and processing vector-based geospatial data

-   **tidyverse -** collection of packages for performing data importation, wrangling and visualization

-   **tmap -** package with functions for plotting cartographic quality maps

-   **sPNetwork** - provides functions for performing SPPA methods like KDE and K-function on a network. The package can also be used to build spatial matrices to conduct traditional spatial analyses with spatial weights based on reticular distances

-   **spatstat** - package for plotting, EDA and simulation of spatial data

#### Import Code

```{r}
pacman::p_load(sf, spNetwork, tmap, tidyverse, spatstat)
```
:::

As we will be performing simulations in the analysis later, it is good practice to define a random seed to be used so that results are consistent for viewers of this report, and the results can be reproduced.

```{r}
set.seed(1234)
```

# B. Data Loading and Preparation

In this section, the appropriate R packages will be used to load the three datasets into R objects, and to inspect and transform them as needed.

## B.1 Thailand Subnational Administrative Boundary, Shapefile

We load the Thailand subnational administrative boundary shapefile into an R dataframe using `st_read()` from the sf package. The source provides the geospatial data in varying levels as indicated by their suffix: country (0), province (1), district (2), and sub-district. (3) For focusing on the BMR, which covers Bangkok and neighboring provinces, province is the most likely level of detail we will need so we will use the code chunk below to load the appropriate layer first.

```{r}
thsab_prov <- st_read(dsn="data/geospatial", 
                   layer="tha_admbnda_adm1_rtsd_20220121")
```

We examine the loaded data to confirm the load has been done properly and to get some initial observations of the data.

::: panel-tabset
#### Calling Object

```{r}
thsab_prov
```

#### Checking crs information with st_crs()

```{r}
st_crs(thsab_prov)
```
:::

The output confirms that we have a multipolygon sf object with 77 rows and 17 columns. There is a column named `ADM1_EN` which appears to contain the province names needed to define the BMR boundaries. It also shows that the dataset is using a coordinate reference system rather than a projected reference system.

First, we reload the data to use a projected reference system and apply the correct reference system with EPSG code of 32647 using `st_transform()`. This transformation can be confirmed with `st_crs()` The **tmap** package is then used to visualize the object to see if it properly depicts the boundaries of Thailand and its provinces.

::: panel-tabset
#### Load Object and Transform CRS information

```{r}
thsab_prov <- st_read(dsn="data/geospatial",
                          layer="tha_admbnda_adm1_rtsd_20220121") %>%
  st_transform(crs = 32647)
```

#### Checking crs information with st_crs()

```{r}
st_crs(thsab_prov)
```

#### Plot of thsab_prov using tmap

```{r}
tm_shape(thsab_prov) +
  tm_polygons("grey")
```
:::

## B.2 Filtering THSAB for the Bangkok Metropolitan Region

Before further analyzing the data, we will limit the scope to only consider the Bangkok Metropolitan Region or BMR. This would encompass Bangkok, Nonthaburi, Nakhon Pathom, Pathum Thani, Samut Prakan, Samut Sakhon. While it is good to get insights outside of BMR, it is out of the study scope and it is best to focus on the objectives.

The code chunk below checks if all the provinces in the BMR appear as is under the `ADM1_EN` column of `thsab_prov`

```{r}
filter(thsab_prov, ADM1_EN %in% c("Bangkok", "Nonthaburi","Nakhon Pathom", "Pathum Thani", "Samut Prakan", "Samut Sakhon"))$ADM1_EN
```

With the previous code returning all 6 provinces, we have confirmation that the provinces are all present and spelled as is in the data source. We create a new object `bmr_boundary` to contain only the provinces in BMR. We also take this opportunity to only keep the relevant columns in the dataset using the **select()** function of dplyr package.

::: panel-tabset
#### Create BMR boundary object using filter()

```{r}
bmr_boundary <- st_read(dsn="data/geospatial",
                      layer="tha_admbnda_adm1_rtsd_20220121") %>%
  st_transform(crs = 32647) %>%
  filter(ADM1_EN %in% c("Bangkok", "Nonthaburi","Nakhon Pathom", "Pathum Thani", "Samut Prakan", "Samut Sakhon")) %>% dplyr::select(Shape_Leng, Shape_Area, ADM1_EN, geometry)
  
```

#### Plot of bmr_boundary using tmap

```{r}
tm_shape(bmr_boundary) +
  tm_polygons("grey")
```
:::

The code below creates a second object which is just a union of all the provinces. (i.e., borders between provinces are lost) This is done using the `st_union()` function.

```{r}
bmr_full = st_union(bmr_boundary)
```

```{r}
tm_shape(bmr_full) +
  tm_polygons("grey")
```

```{r}
#| echo: false
rm(thsab_prov)
```

The code below keeps the final boundary objects into files to make loading more convenient for later analyses.

```{r}
#| eval: false 
write_rds(bmr_boundary, "data/rds/bmr_boundary.rds")
write_rds(bmr_full, "data/rds/bmr_full.rds")
```

The code below then reloads the same objects into R:

```{r}
#| eval: false
bmr_boundary = read_rds("data/rds/bmr_boundary.rds")
bmr_full = read_rds("data/rds/bmr_full.rds")
```

## B.3 Road Accident Data, Aspatial, csv-file

The road accident data is contained in a csv file. We use the code block in the first tab below to load it into the `thra` object with some necessary transformations that we identified upon inspecting the raw file. The second tab gives an explanation of the different nested functions used in the code

::: panel-tabset
#### Code to import and transform road accident data

```{r}
#| eval: false
bmracc <- read_csv("data/aspatial/thai_road_accident_2019_2022.csv")  %>%
  filter(!is.na(longitude) & longitude != "", 
         !is.na(latitude) & latitude != "") %>%
  st_as_sf(coords = c("longitude", "latitude"), crs=4326) %>%
  st_transform(crs = 32647)

bmracc <- filter(bmracc, geometry %in% st_intersection(bmr_full, bmracc)) %>%
  mutate(Year = year(incident_datetime)) %>%
  mutate(MonthNum = month(incident_datetime)) %>%
  mutate(Month = month(incident_datetime, label = TRUE, abbr = TRUE)) %>%
  mutate(DayOfWeek = wday(incident_datetime, label = TRUE, abbr = TRUE))


```

#### Explanation of the code lines / functions used

-   `read_csv()` used to import a csv file into an R object

-   `filter(!is.na(longitude) & longitude != "", !is.na(latitude) & latitude != "")` used to exclude any records where the longitude or latitude information is missing

-   `st_as_sf(coords = c("longitude", "latitude"), crs=4326)` used to convert the dataframe into an sf object using a reference system (WGS84) based on the coordinates

-   `st_transform(crs = 32647)` used to apply the correct EPSG code to the sf object

-   `filter(bmracc, geometry %in% st_intersection(bmr_full, bmracc))` used to leave only records which fall within the BMR boundaries

-   `mutate(...)` these lines are used to add additional columns to quickly reference the year, month and day of the week that each accident occured as these dimensions allow for some temporal analyses
:::

Calling the new object shows that it has 12,989 rows across 20 fields.

```{r}
#| eval: false
bmracc
```

We use the code chunks below to check the data and visualize the data on the BMR boundary map.

```{r}
#| echo: false
bmracc <- read_rds("data/rds/bmracc.rds")
```

```{r}
tm_shape(bmr_boundary) +
  tm_polygons(col = "grey") +
  tm_shape(bmracc) +
  tm_dots(col = "red", size = 0.01, alpha = 0.5)
```

The code chunk below writes the resulting accident dataset into an rds file for convenient loading.

```{r}
#| eval: false
write_rds(bmracc, "data/rds/bmracc.rds")
```

## B.4 Thailand Roads Open StreetMap, Shapefile

The second geospatial object is the street map shapefile. We will use the object `network` to contain the final road network for the study.

```{r}
#| eval: false
network <- st_read(dsn="data/geospatial",
                      layer="hotosm_tha_roads_lines_shp")
```

Running the above code confirms that the dataset is in multilinestring sf format and that it contains 2.8M records across 15 variables. It also shows that there is no CRS applied to the dataset.

Based on these, the following steps need to be done: apply the right CRS/EPSG code of 32647 or the same as `bmr_full`, and, filter the network to only include BMR.

The code below does the first step of applying a reference system and updating the EPSG code to 32647 using `st_set_crs()` and `st_crs()` from the sf package.

```{r}
#| eval: false
network <- st_read(dsn="data/geospatial",
                      layer="hotosm_tha_roads_lines_shp") %>%
  st_make_valid() %>% st_set_crs(4326) %>% st_transform(crs = st_crs(bmr_full))

```

The code below then finds the network within BMR by using `st_intersection()` to find the overlap between the full road network and the BMR boundary. We also include `write_rds()` in the chunk to store this object into an rds file for easy future loading.

```{r}
#| eval: false
network <- st_intersection(network, bmr_full)
write_rds(network, "data/rds/network.rds")
```

Calling the object name allows us to inspect the contents.

```{r}
#| eval: false
network
```

The size of the object has now been reduced to 585K features from the original 2.8M. This still appears a very large number if we want to visualize the data, so we need to inspect if there are any opportunities to reduce the dataset by excluding any irrelevant records.

The data includes a column named highway which gives information on the the type or classification of the road.

```{r, fig.width=15, fig.height=8}
#| eval: false
ggplot(network, aes(x = reorder(highway, table(highway)[highway]))) +
  geom_bar() +
  coord_flip() +
  ggtitle("Number of Roads by Highway type") +
  theme_minimal() +
  geom_text(stat='count', aes(label=..count..), hjust=-0.3) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12),
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  labs(x = "Highway Type", y = "Number of Roads")
```

The resulting chart shows that roads with highway type of **residential** and **service** make up 522K of the 585K roads in the dataset. We refer to the OpenStreetMap wiki page to see the definition of the [different types of highways](https://wiki.openstreetmap.org/wiki/WikiProject_Thailand#Highway_classification) in the Thailand map and see that these two highway types are access roads for residences or specific buildings. For our objective, we should be able to limit to roads where accidents (are expected to frequently) happen, and only to roads that should be accessible by vehicles. Going through the definition of the highway types, we see that the following 6 types could be out of scope for our study:

-   residential - road within a residential area that gives public access to one or multiple residences

-   service - minor road that gives access to buildings or places outside a residential area (e.g., to a religious site, an attraction, part of an estate)

-   footway - pathways designed for pedestrian access

-   track - road whose only function is to provide access to surrounding land, and is most of the time unpaved

-   path - multi-purpose path intended for non-motor vehicles

-   steps

We can then use the following code chunk which uses the `filter()` function to remove these classifications from the current `network` object. We call the object name in the succeeding code chunk to check the new dataset.

```{r}
#| echo: false
bmr_network = read_rds("data/rds/bmr_network.rds")
```

```{r}
#| eval: false
bmr_network <- bmr_network %>% 
  filter(!(highway %in% c("residential", "service", "footway", "track", "path", "steps")))
```

```{r}
#| eval: false
bmr_network
```

While this looks good, it looks like the object is being identified as a GEOMETRY rather than a LINESTRING object. We can use the code below to correct it.

```{r}
#| eval: false
bmr_network <- st_cast(bmr_network, "LINESTRING")
```

```{r}
#| eval: false
bmr_network
```

The new road network object is now reduced to 34K records or roads which is a 94% reduction in the number of records. We will use some visual inspection to see if this reduction in records will affect our analysis. The two code chunks below plot the road network within the boundaries, while the second plots the three objects together. We use the tmap function to create these maps.

::: panel-tabset
#### BMR filtered road network only

```{r}

tm_shape(bmr_full) +
  tm_polygons(col = "lightgrey") +
  tm_shape(bmr_network) +
  tm_lines(col = "black")

```

#### BMR filtered road network with road accident dataset

```{r}
tm_shape(bmr_full) +
  tm_polygons(col = "lightgrey") +
  tm_shape(bmr_network) +
  tm_lines(col = "black") +
  tm_shape(bmracc) +
  tm_dots(col = "red", alpha = 0.2)
```
:::

From these two maps, we see that:

1.  while we have filtered 90% of the original records, the resulting map still appears dense, especially in some central areas; and,

2.  the road accident locations appear to fall along the network

Based on these, we will go ahead with this version of the network for our analysis.

The following code writes the resulting network into an rds file for more convenient loading in the future.

```{r}
#| eval: false
write_rds(bmr_network, "data/rds/bmr_network.rds")
```

## B.5 Resolving duplicate points

In this section, we perform some additional transformations to perform the required analyses.

First, we check the event or accident dataset to see if there are any **duplicated data points** or locations as the methods require that the points are unique. The code below checks if any duplicate points exist. Note that we specify the column in the argument as we are double-checking duplicate locations rather than completely duplicate records.

```{r}
any(duplicated(bmracc$geometry))
```

As the code returned TRUE, it confirms the presence of duplicate points, we use `st_jitter()` from the **sf** package to introduce some jitter to each point and ensure that points do not lie on the same location. Without any additional arguments, the function uses a default factor 0.002 of the bounding box diagonal as the bounds for the amount of jitter introduced. In the code below, we define an amount of 0.01 instead.

```{r}
bmracc <- st_jitter(bmracc, 0.01)
```

Rerunning the check using `duplicated()` shows that there are no duplicate points anymore.

```{r}
any(duplicated(bmracc$geometry))
```

# C. NonSpatial Data Analysis

Before we go into performing spatial or spatio-temporal analysis, it would be good to explore and examine the data further. This can reveal some insights and also clarify what variables we can use for drilling down on the required analysis.

## C.1 Categories of accidents

We first would like to understand the different labels we can use from the BMR road accident dataset `bmracc` The following columns appear to be able to give some insight about the nature of the accident:

-   vehicle_type

-   presumed_cause

-   accident_type

-   number_of_vehicles_involved

-   number_of_fatalities

-   weather_condition

We will try to be brief in analysing these variables as the main intent is to understand which ones will add the most value to the spatial analysis needed to address the main study objectives.

### C.1.1 Vehicle Type

This variable is intended to give the type of vehicle involved in the accident. We use the code block below to understand the categories under this variable using a simple bar chart created through `ggplot()`.

```{r, fig.width=15, fig.height=8}
ggplot(bmracc, aes(x = reorder(vehicle_type, table(vehicle_type)[vehicle_type]))) +
  geom_bar() +
  coord_flip() +
  ggtitle("Number of Accidents by Vehicle type") +
  theme_minimal() +
  geom_text(stat='count', aes(label=..count..), hjust=-0.3) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title.x = element_text(size = 15),
    axis.title.y = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  labs(x = "", y = "")
```

The output shows that out of 12,989 accidents, 35% are with private or passenger cars, 27% are with pickup trucks and 13% are with motorcycles. These three make up 75% of all the recorded accidents while the remaining 11 types make up the balance 25%

### C.1.2 Presumed Cause

This variable is intended to give the presumed cause of the accident. We again use the code block below to understand the categories under this variable using a simple bar chart created through `ggplot()`.

```{r , fig.width=15, fig.height=8}
ggplot(bmracc, aes(x = reorder(presumed_cause, table(presumed_cause)[presumed_cause]))) +
  geom_bar() +
  coord_flip() +
  ggtitle("Number of Accidents by Presumed Cause") +
  theme_minimal() +
  geom_text(stat='count', aes(label=..count..), hjust=-0.3) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title.x = element_text(size = 15),
    axis.title.y = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  labs(x = "", y = "")

```

The chart shows that 10,146 or 75% of the accidents are presumed to be caused by speeding. The next largest named presumed cause only accounts for 5% of the overall data.

### C.1.3 Accident Type

This variable is intended to give the type or nature of the accident. We again use the code block below to understand the categories under this variable using a simple bar chart created through `ggplot()`.

```{r , fig.width=15, fig.height=8}
ggplot(bmracc, aes(x = reorder(accident_type, table(accident_type)[accident_type]))) +
  geom_bar() +
  coord_flip() +
  ggtitle("Number of Accidents by Type") +
  theme_minimal() +
  geom_text(stat='count', aes(label=..count..), hjust=-0.3) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title.x = element_text(size = 15),
    axis.title.y = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  labs(x = "", y = "")

```

The chart shows that "rear-end collisions" and "rollover/fallen on straight road" are the leading causes recorded and account for 83% of the accidents.

### C.1.4 Number of Fatalities

This variable is intended to give the number of fatalities resulting from the accident. We again use the code block below to understand the categories under this variable using a simple histogram created through `ggplot()`.

```{r}
ggplot(bmracc, aes(x = number_of_fatalities)) +
  geom_histogram(binwidth = 1, color = "black", fill = "darkgrey") +
  scale_x_continuous(breaks = seq(min(bmracc$number_of_fatalities), max(bmracc$number_of_fatalities), by = 1)) +
  labs(title = "Accidents by Number of Fatalities", x = "Number of Fatalities", y = "Number of Accidents") +
  theme_minimal() +
  theme(panel.grid = element_blank()) +
  geom_text(stat='count', aes(label=..count..), vjust=-0.5)
```

The plot shows that 94% of the recorded accidents are non-fatal. Only 719 were fatal. Although this is a small number, it might be worth looking at the location of such fatal accidents later. We can use the code below to introduce a new column `fatal` into the data for more convenient filtering later.

```{r}
bmracc$fatal <- bmracc$number_of_fatalities > 0
```

### C.1.5 Weather Condition

This variable is intended to indicate the weather condition when the accident was recorded. We first use the code block below to understand the categories under this variable using a simple bar chart created through `ggplot()`.

```{r , fig.width=15, fig.height=8}
ggplot(bmracc, aes(x = reorder(weather_condition, table(weather_condition)[weather_condition]))) +
  geom_bar() +
  coord_flip() +
  ggtitle("Number of Accidents by Weather Condition") +
  theme_minimal() +
  geom_text(stat='count', aes(label=..count..), hjust=-0.3) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title.x = element_text(size = 15),
    axis.title.y = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  labs(x = "", y = "")

```

The chart shows that 90% of the accidents occurred during "clear" weather. Online sources suggest that Bangkok experieces a long rainy season and has [153 rainy days per year](https://weatherandclimate.com/thailand/bangkok), so 10% for the occurrence of accidents appears low. The sources also say that the wettest month is September.

We can use the code chunk below to plot the number of accidents that were not recorded on clear weather (i.e., rainy) by month.

```{r , fig.width=15, fig.height=8}

ggplot(filter(bmracc, !weather_condition == "clear"), aes(x = reorder(Month, table(Month)[Month]))) +
  geom_bar() +
  coord_flip() +
  ggtitle("Number of Accidents by Month during Non-clear Weather") +
  theme_minimal() +
  geom_text(stat='count', aes(label=..count..), hjust=-0.3) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title.x = element_text(size = 15),
    axis.title.y = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  labs(x = "", y = "")
```

The plot does align with the expectation that September is the wettest month. The very low number of accidents during rainy weather is still questionable though so we will watch out for this if we will use this variable later.

# D. Spatiotemporal Visualizations of Road Accidents in BMR

In this section, we visualize the locations of accidents using different dimensions, especially based on time. For our objectives, we are concerned about the locations of accidents along the roads, so we will explore both the point locations as well as network-constrained visualizations.

## D.1 Preparation of Data for Network Constrained Analysis

Before we are able to perform network-constrained NKDE, we first need to define sample points along the road network, and to do that, we can use the midpoint of the lixels of the network.

### D.1.1 Preparing the lixels

To lixelize a network, the minimum and (maximum) length of lixels need to be defined. A logical distance needs to be chosen for a given study. In our case, we might no have enough information to understand what road segment length is relevant to group accidents into. However, we can start with understanding the road lengths in the network.

We can use the code block below to show the distribution of the road length values using `summary()` to give the quartiles, and `quantile()` to give a wider range of view.

```{r}
summary(st_length(bmr_network))

quantile(st_length(bmr_network), probs = seq(.1, .9, by = .1))
```

The output shows that there is a very wide range of values. There is also a surprisingly large number of roads (\>40%) that are less than 100mâ€“ which seem to be too short for typical roads. We can choose a range of 100-500m for lixel length, and this would keep at least 40% of the roads intact, while the balance will either be merged or split.

We implement this using `lixelize_lines()` in the code chunk below.

```{r}
lixels <- lixelize_lines(bmr_network$geometry, 
                         500, 
                         mindist = 100)
```

### D.1.2 Generating sample points

The next step is to define sample points along the network which will be the points where the KDE function will be computed on.

We can create sample points on the lixel centers using `lines_center()` in the code below.

```{r}
samples <- lines_center(lixels) 
```

## D.2 Total and Annual Level Analysis

Let's start by looking at the highest levels. We can compute for the nkde for all accidents in the dataset (2019-2022) using the code chunk below.

```{r}
densities <- nkde(bmr_network, 
                  events = bmracc,
                  w = rep(1, nrow(bmracc)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(10,10), 
                  max_depth = 8,
                  agg = 5, 
                  sparse = TRUE,
                  verbose = FALSE)
```

We import the densities into the lixel and sample object using the code below. We use a multiple of 1000 to convert the figures from accidents per square meter to accidents per square kilometer

```{r}
samples$density_all <- densities*1000000
lixels$density_all <- densities*1000000
```

We use the code below to produce an interactive map with just the calculated densities.

```{r}
tmap_mode("view")
tm_shape(lixels)+
  tm_lines(col="density_all")
tmap_mode("plot")
```
