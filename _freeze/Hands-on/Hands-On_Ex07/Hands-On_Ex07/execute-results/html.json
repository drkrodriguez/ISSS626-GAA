{
  "hash": "042a881e892263118ef2f86cdcafecf8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Global Measures of Spatial Autocorrelation\"\nauthor: \"Federico Jose Rodriguez\"\ndate: \"Sep 22 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n\nIn this hands-on exercise, we learn how to compute and interpret global measures of spatial autocorrelation (GMSA) using the **spdep** package.\n\nThis exercise is based on Chapter 9 of Dr Kam's online book which can be accessed [here](https://r4gdsa.netlify.app/ \"R for Geospatial Data Science and Analytics by Dr Kam\").\n\n# Getting Started\n\n## Analytical Question\n\nOne of the main development objective in spatial policy is for local governments and planners to ensure that there is equal distribution of development in the province. We then need to apply the appropriate spatial methods to verify if there is indeed even distribution of wealth geographically. If there is uneven distribution, then the next step is to identify if and where clusters are happening.\n\nWe continue studying the Hunan Province in China and focus on GDP per capita as the key indicator of development.\n\n## Data Sources\n\nData for this exercise are based on the Hunan county coming from two files:\n\n-   Hunan county boundary layer in ESRI shapefile format\n\n-   Hunan local development indicators for 2012 stored in a csv file\n\n## Installing and launching R packages\n\nThis exercise will make use of five R packages: **sf**, **tidyverse,** **tmap, and spdep**.\n\n-   **sf -** for importing, managing and processing vector-based geospatial data\n\n-   **tidyverse -** collection of packages for performing data importation, wrangling and visualization\n\n-   **tmap -** for plotting cartographic quality maps\n\n-   **spdep** - functions to create spatial weights, autocorrelation statistics\n\nThe code chunk below uses `p_load()` of **pacman** package to check if the packages are installed in the computer. It installs them first if they are not. It then loads them into R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse)\n```\n:::\n\n\n\nWe also define a random seed value for repeatability of any simulation results.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n\n# Data Import and Preparation\n\n## Data Loading\n\nThe code chunk below uses `st_read()` of the **sf** package to load the Hunan shapefile into an R object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\Hands-on\\Hands-On_Ex07\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n\nWe then use the code chunk below to load the csv file with the indicators into R using `read_csv()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n## Data Preparation\n\nWe then update the first object, which is of sf type, by adding in the economic indicators from the second object using `left_join()` as in the code chunk below\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan,hunan2012) %>%\n  select(1:4, 7, 15)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(County)`\n```\n\n\n:::\n:::\n\n\n\nIf we check the contents of `hunan` using `head()`, we see that it now includes a column `GDDPPC`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3  County GDPPC\n1 Changde 21098 Anxiang      County Anxiang 23667\n2 Changde 21100 Hanshou      County Hanshou 20981\n3 Changde 21101  Jinshi County City  Jinshi 34592\n4 Changde 21102      Li      County      Li 24473\n5 Changde 21103   Linli      County   Linli 25554\n6 Changde 21104  Shimen      County  Shimen 27137\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n```\n\n\n:::\n:::\n\n\n\n## Visualization of the Development Indicator\n\nBefore we move to the main analyses, we can visualize the distribution of GCPPC by using **tmap** package. We present these uas two maps using classes of equal intervals and equal quantiles.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex07_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n# Global Measures of Spatial Autocorrelation: Preparation\n\nIn the succeeding sections, we compute global spatial autocorrelation statistics and perform spatial CSR test for global spatial autocorrelation.\n\n## Computing Contiguity Spatial Weights\n\nPrior to computing GMSA's, we need t construct spatial weights of the study area. Spatial weights are used to define the neighborhood relationship between units. (i.e., neighbors or adjacent units)\n\nThe code chunk below uses `poly2nb()` of the **spdep** package to compute contiguity weight matrices for the study area. The function builds a neighbor list based on regions with shared boundaries. The `queen` argument takes TRUE (default) or FALSE as options. This instructs the function if Queen criteria should be used in defining neighbors. For the code below, we use the Queen criteria to build the contiguity matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, \n                queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n\n\n:::\n:::\n\n\n\nThe output shows that there are 88 units in the `hunan` dataset, The most connected unit has 11 neighbors and two units have only one neighbor.\n\n## Row-standardised weights matrix\n\nThe next step is assigning weights to each neighbor. For our case, we assign equal weight (using `style=\"W\"`) to each neighboring polygon. This assigns the fraction 1/n, where n is the number of neighbors a unit has, as the weight of each unit's neighbor. The drawback of this approach is that polygons in the edge of the study area will base their value on a smaller number of neighbors. This means that we may be potentially over- or under-estimating the true nature of spatial autocorrelation. The alternative more robust `style=\"B\"` can address this.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n\n\n:::\n:::\n\n\n\n# Global Measures of Spatial Autocorrelation: Moran's I\n\nIn this section, we compute for Moran's I statistics by using `moran.test()` of the **spdep** package.\n\n## Moran's I test\n\nThe code chunk below performs Moran's I statistical testing using `moran.test()` of the **spdep** package\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n\nThe p-value does not support CSR for the GDPPC, while a positive statistic indicates signs of clustering. If the statistic value were below 0, or negative, then it would indicate signs of dispersion.\n\n## Monte Carlo Simulation for Moran's I\n\nWe use the code chunk below to perform permutation test for the statistic by using `moran.mc()` of **spdep**. The `nsim` argument is set so that 1000 simulations will be performed.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm= moran.mc(hunan$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n\n## Visualization of Monte Carlo Simulation Results (Moran's I)\n\nIt is good practice to analyse and visualize the simulation results in more detail. We can do this by checking the values and distribution of the statistic numerically and graphically.\n\nWe can use the code chunk below to show individual statistics of the simulated value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n```\n\n\n:::\n\n```{.r .cell-code}\npaste(\"Standard Dev:\", var(bperm$res[1:999]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Standard Dev: 0.00437157393477615\"\n```\n\n\n:::\n:::\n\n\n\nWe can visualize graphically using `hist()` and `abline()` from R Graphics.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex07_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n# Global Measures of Spatial Autocorrelation: Geary's C\n\nIn this section, we compute for Geary's C statistic by using the spdep package\n\n## Geary's C test\n\nThe code chunk below uses `geary.test()` to perform Geary's C test for spatial autocorrelation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeary.test(hunan$GDPPC, listw=rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tGeary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q   \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n```\n\n\n:::\n:::\n\n\n\nGeary's C test uses a different interpretation compared to Moran's I. A statistic value less than one, as in the case above, indicates signs of clustering, while a value of greater than one indicates dispersion. The very low p-value means that any hypothesis of compete spatial randomness (with α \\> 0.015%) is not supported by the observed data.\n\n## Monte Carlo Simulation for Geary's C\n\nWe use the code chunk below to perform permutation test for the statistic by using `geary.mc()` of **spdep**. The `nsim` argument is set so that 1000 simulations will be performed.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm=geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n\n## Visualization of Monte Carlo Simulation Results (Geary's C)\n\nIt is good practice to analyse and visualize the simulation results in more detail. We can do this by checking the values and distribution of the statistic numerically and graphically.\n\nWe can use the code chunk below to show individual statistics of the simulated value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n```\n\n\n:::\n\n```{.r .cell-code}\npaste(\"Standard Dev:\", var(bperm$res[1:999]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Standard Dev: 0.00743649278244122\"\n```\n\n\n:::\n:::\n\n\n\nWe can visualize graphically using `hist()` and `abline()` from R Graphics.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res,\n     freq=TRUE,\n     breaks=20,\n     xlab=\"Simulated Geary c\")\nabline(v=1, col=\"red\") \n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex07_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n# Spatial Correlogram\n\nSpatial correlograms let us examine patterns of spatial autocorrelation in the data or in the model residuals. They show correlation between pairs of observations when the distance between them are increased. they plot an index of correlation (e.g., Moran's I or Geary's C) against the distance.\n\n## Moran's I Correlogram and Plot\n\nThe code chunk below uses `sp.correlogram()` of spdep package to compute a 6-lag (`order=6`) spatial correlogram of GDPPC using Moran's I. (`method=\"I\"`) We then `plot()` to produce the visualization.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex07_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\nAside from the output, we can also display the full content of the analysis using the code below. This lets us see the result for each lag in more detail.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(MI_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n\n## Geary's C Correlogram and Plot\n\nThe code chunk below uses `sp.correlogram()` of spdep package to compute a 6-lag (`order=6`) spatial correlogram of GDPPC using Geary's C. (`method=\"C\"`) We then `plot()` to produce the visualization.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex07_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nWe can also examine the results in more detail using the code chunk below\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(GC_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n",
    "supporting": [
      "Hands-On_Ex07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}