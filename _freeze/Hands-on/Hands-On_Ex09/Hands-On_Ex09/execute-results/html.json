{
  "hash": "450e09d689032cf98432b0f2bc31c21d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Geographic Segmentation wwith Spatially Constrained Clustering Techniques\"\nauthor: \"Federico Jose Rodriguez\"\ndate: \"Sep 27 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n\nIn this hands-on exercise, we apply hierarchical cluster analysis and spatially constrained cluster analysis to delineate homogeneous regions based on geographically referenced data.\n\nThis exercise is based on Chapter 12 of Dr Kam's online book which can be accessed [here](https://r4gdsa.netlify.app/ \"R for Geospatial Data Science and Analytics by Dr Kam\").\n\n# Getting Started\n\n## Analytical Question\n\nIn the development of spatial policy and for business, it is often important to segregate homogenous regions using multivariate data. We apply techniques in the study of Shan State in Myanmar by using various indicators.\n\n## Data Sources\n\nData for this exercise are based on information for Myanmar and for its Shan state:\n\n-   Myanmar township boundary data in ESRI shapefile format (polygon)\n\n-   Shan state ICT indicators for 2014 contained in a csv file\n\n## Installing and launching R packages\n\nThis exercise will make use of thirteen R packages:\n\n-   **sf, rgdal, spdep -** for spatial data handling\n\n-   **tidyverse -** collection of packages for performing data importation, wrangling and visualization\n\n-   **tmap -** for plotting cartographic quality maps\n\n-   **coorplot, ggpubr, heatmaply** - packages for multivariate data visualization and analysis\n\n-   **cluster, ClustGeo** - packages for performing cluster analysis\n\nThe code chunk below uses `p_load()` of **pacman** package to check if the packages are installed in the computer. It installs them first if they are not. It then loads them into R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n:::\n\n\n\nWe also define a random seed value for repeatability where of any randmoized results.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n\n# Data Import and Preparation\n\n## Data Loading - Shan state boundary\n\nThe code chunk below uses `st_read()` of the **sf** package to load the Myanmar township boundary shapefile into an R object. The code chunk includes a pipeline to already filter to the Shan state and include only the relevant columns.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %>%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `myanmar_township_boundaries' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\Hands-on\\Hands-On_Ex09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 330 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.17275 ymin: 9.671252 xmax: 101.1699 ymax: 28.54554\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n\nWe can inspect the contents of shan_sf using the code chunk below\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 55 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.15107 ymin: 19.29932 xmax: 101.1699 ymax: 24.15907\nGeodetic CRS:  WGS 84\nFirst 10 features:\n             ST ST_PCODE       DT   DT_PCODE        TS  TS_PCODE\n1  Shan (North)   MMR015  Mongmit MMR015D008   Mongmit MMR015017\n2  Shan (South)   MMR014 Taunggyi MMR014D001   Pindaya MMR014006\n3  Shan (South)   MMR014 Taunggyi MMR014D001   Ywangan MMR014007\n4  Shan (South)   MMR014 Taunggyi MMR014D001  Pinlaung MMR014009\n5  Shan (North)   MMR015  Mongmit MMR015D008    Mabein MMR015018\n6  Shan (South)   MMR014 Taunggyi MMR014D001     Kalaw MMR014005\n7  Shan (South)   MMR014 Taunggyi MMR014D001     Pekon MMR014010\n8  Shan (South)   MMR014 Taunggyi MMR014D001  Lawksawk MMR014008\n9  Shan (North)   MMR015  Kyaukme MMR015D003 Nawnghkio MMR015013\n10 Shan (North)   MMR015  Kyaukme MMR015D003   Kyaukme MMR015012\n                         geometry\n1  MULTIPOLYGON (((96.96001 23...\n2  MULTIPOLYGON (((96.7731 21....\n3  MULTIPOLYGON (((96.78483 21...\n4  MULTIPOLYGON (((96.49518 20...\n5  MULTIPOLYGON (((96.66306 24...\n6  MULTIPOLYGON (((96.49518 20...\n7  MULTIPOLYGON (((97.14738 19...\n8  MULTIPOLYGON (((96.94981 22...\n9  MULTIPOLYGON (((96.75648 22...\n10 MULTIPOLYGON (((96.95498 22...\n```\n\n\n:::\n:::\n\n\n\nThe sf dataframe conforms to the tidy framework. Given this, we can also use `glimpse()` to reveal the fields' data types.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(shan_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 55\nColumns: 7\n$ ST       <chr> \"Shan (North)\", \"Shan (South)\", \"Shan (South)\", \"Shan (South)…\n$ ST_PCODE <chr> \"MMR015\", \"MMR014\", \"MMR014\", \"MMR014\", \"MMR015\", \"MMR014\", \"…\n$ DT       <chr> \"Mongmit\", \"Taunggyi\", \"Taunggyi\", \"Taunggyi\", \"Mongmit\", \"Ta…\n$ DT_PCODE <chr> \"MMR015D008\", \"MMR014D001\", \"MMR014D001\", \"MMR014D001\", \"MMR0…\n$ TS       <chr> \"Mongmit\", \"Pindaya\", \"Ywangan\", \"Pinlaung\", \"Mabein\", \"Kalaw…\n$ TS_PCODE <chr> \"MMR015017\", \"MMR014006\", \"MMR014007\", \"MMR014009\", \"MMR01501…\n$ geometry <MULTIPOLYGON [°]> MULTIPOLYGON (((96.96001 23..., MULTIPOLYGON (((…\n```\n\n\n:::\n:::\n\n\n\n## Data Loading - Shan state 2014 indicators (aspatial)\n\nThe code chunk below uses `read_csv()` to load the contents of the csv file into an object `ict`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 55 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): District Pcode, District Name, Township Pcode, Township Name\ndbl (7): Total households, Radio, Television, Land line phone, Mobile phone,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\nWe can use `head()` to check the first 6 elements of the object,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ict)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 11\n  `District Pcode` `District Name` `Township Pcode` `Township Name`\n  <chr>            <chr>           <chr>            <chr>          \n1 MMR014D001       Taunggyi        MMR014001        Taunggyi       \n2 MMR014D001       Taunggyi        MMR014002        Nyaungshwe     \n3 MMR014D001       Taunggyi        MMR014003        Hopong         \n4 MMR014D001       Taunggyi        MMR014004        Hsihseng       \n5 MMR014D001       Taunggyi        MMR014005        Kalaw          \n6 MMR014D001       Taunggyi        MMR014006        Pindaya        \n# ℹ 7 more variables: `Total households` <dbl>, Radio <dbl>, Television <dbl>,\n#   `Land line phone` <dbl>, `Mobile phone` <dbl>, Computer <dbl>,\n#   `Internet at home` <dbl>\n```\n\n\n:::\n:::\n\n\n\nand `summary()` to display summary statistics of the numeric columns.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ict)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n District Pcode     District Name      Township Pcode     Township Name     \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n Total households     Radio         Television    Land line phone \n Min.   : 3318    Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711    1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685    Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369    Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471    3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604    Max.   :30176   Max.   :62388   Max.   :6736.0  \n  Mobile phone      Computer      Internet at home\n Min.   :  150   Min.   :  20.0   Min.   :   8.0  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0  \n Median : 3559   Median : 244.0   Median : 316.0  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0  \n```\n\n\n:::\n:::\n\n\n\nThe dataset contains 11 fields with 55 observations. The numeric fields give the total number of households in each township, and the number of households with the corresponding technology or appliance. (e.g., television, internet connection, etc)\n\n## Deriving new indicator variables\n\nUsing the numeric fields directly will be highly biased as it depends on the number of households in the township. (i.e., townships with higher total households are likely to have higher values for all other columns) To overcome this problem, we can derive the penetration rates (PR) of each of the items by computing the number of households with that item per 1000 households. We accomplish this using `mutate()` from dplyr package in the code below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict_derived <- ict %>%\n  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%\n  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%\n  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%\n  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%\n  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%\n  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%\n  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,\n         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,\n         `TT_HOUSEHOLDS`=`Total households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) \n```\n:::\n\n\n\nWe can use `summary()` again to display summary statistics on the 6 new columns.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ict_derived[c(12:17)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    RADIO_PR          TV_PR         LLPHONE_PR       MPHONE_PR     \n Min.   : 21.05   Min.   :116.0   Min.   :  2.78   Min.   : 36.42  \n 1st Qu.:138.95   1st Qu.:450.2   1st Qu.: 22.84   1st Qu.:190.14  \n Median :210.95   Median :517.2   Median : 37.59   Median :305.27  \n Mean   :215.68   Mean   :509.5   Mean   : 51.09   Mean   :314.05  \n 3rd Qu.:268.07   3rd Qu.:606.4   3rd Qu.: 69.72   3rd Qu.:428.43  \n Max.   :484.52   Max.   :842.5   Max.   :181.49   Max.   :735.43  \n  COMPUTER_PR      INTERNET_PR     \n Min.   : 3.278   Min.   :  1.041  \n 1st Qu.:11.832   1st Qu.:  8.617  \n Median :18.970   Median : 22.829  \n Mean   :24.393   Mean   : 30.644  \n 3rd Qu.:29.897   3rd Qu.: 41.281  \n Max.   :92.402   Max.   :117.985  \n```\n\n\n:::\n:::\n\n\n\n## Joining spatial and aspatial data\n\nFor later map preparations, we need to combine the two datasets (geospatial `shan_sf`, aspatial `ict_derived`) into a single object. We do this using the `left_join()` function of the **dplyr** package. Both datasets have a common field `TS_PCODE` which will be treated as the unique identifier or joining key.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- left_join(shan_sf, \n                     ict_derived, by=c(\"TS_PCODE\"=\"TS_PCODE\"))\n  \nwrite_rds(shan_sf, \"data/rds/shan_sf.rds\")\n```\n:::\n\n\n\nThe code includes creation of a new rds file so we can use the following code in the future to read this joined dataset without performing all the steps above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- read_rds(\"data/rds/shan_sf.rds\")\n```\n:::\n\n\n\n# Exploratory Data Analysis (EDA)\n\n## EDA using statistical graphics\n\nWe can use histograms to visualize the overall distribution of data values– e.g., the shape or skewness. The code chunk below produces on for the field `RADIO_PR`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20,  color=\"black\", fill=\"light blue\") +\n  xlab(\"Radio Penetration Rate, per K-HH\") +\n  ylab(\"No. of Townships\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\nWe can also use boxplots for identifying the median, quartiles, and outliers in the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")+\n  xlab(\"Radio Penetration Rate, per K-HH\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\nWe can create multiple histograms side by side by creating objects for each variable's histogram, and then laying them out in a grid with `ggarange()` of the **ggpubr** package.\n\n::: panel-tabset\n#### Creation of Histogram objects\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nradio <- ggplot(data=ict_derived, aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20,color=\"black\", fill=\"light blue\") +\n  xlab(\"Radio PR\") +\n  ylab(\"No. of Townships\")\n\ntv <- ggplot(data=ict_derived, aes(x= `TV_PR`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\") +\n  xlab(\"TV PR\") +\n  ylab(\"No. of Townships\")\n\nllphone <- ggplot(data=ict_derived, aes(x= `LLPHONE_PR`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\") +\n  xlab(\"Landline Phone PR\") +\n  ylab(\"No. of Townships\")\n\nmphone <- ggplot(data=ict_derived, aes(x= `MPHONE_PR`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\") +\n  xlab(\"Mobile Phone PR\") +\n  ylab(\"No. of Townships\")\n\ncomputer <- ggplot(data=ict_derived, aes(x= `COMPUTER_PR`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\") +\n  xlab(\"Computer PR\") +\n  ylab(\"No. of Townships\")\n\ninternet <- ggplot(data=ict_derived, aes(x= `INTERNET_PR`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\") +\n  xlab(\"Internet PR\") +\n  ylab(\"No. of Townships\")\n```\n:::\n\n\n\n#### Grid display of multiple histograms\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggarrange(radio, tv, llphone, mphone, computer, internet, \n          ncol = 3, nrow = 2)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## EDA using choropleth map\n\nThe code chunk below prepares a choropleth map of the Shan state and the Radio penetration rate using `qtm()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf, \"RADIO_PR\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nThe above map is based on the derived penetration rate. We can use choropleth maps to go back to the earliest statement that using the raw variables are likely to be biased on the number of households. We can use the code chunk below to look at them side by side. We use the approach of passing multiple arguments instead of using `tmap_arrange()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(shan_sf) + \n  tm_fill(col = c(\"TT_HOUSEHOLDS\", \"RADIO\"),\n          n = 5,style = \"jenks\", \n          title = c(\"Total households\",\"Number Radio\")) + \n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.position = c(\"right\", \"top\"), bg.color = \"grey90\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\nThe above map shows that townships with high number of households with radios, also are towns with the high number of households. We can produce a second map to see if the penetration rate and the total number of households are correlated.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(shan_sf) + \n  tm_fill(col = c(\"TT_HOUSEHOLDS\", \"RADIO_PR\"),\n          n = 5,style = \"jenks\", \n          title = c(\"Total households\",\"Radio Penetration\")) + \n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.position = c(\"right\", \"top\"), bg.color = \"grey90\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\nThe second pair of maps shows no strong correlation between townships having high number of households and having high radio penetration rates.\n\nFinally, we can show the six derived variables visually using a similar approach in the code chunk below. The viewer needs to be mindful of the data classes. While the darker the shading means a higher value for that derived variable, the range of values are different between pairs of variables.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(shan_sf) + \n  tm_fill(col = c(\"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\",\n                  \"MPHONE_PR\", \"COMPUTER_PR\", \"INTERNET_PR\"),\n          n = 5,style = \"jenks\") + \n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.position = c(\"right\", \"top\"), bg.color = \"grey90\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n# Correlation Analysis\n\nBefore we perform cluster analysis, it is important to check that the cluster variables are not highly correlated.\n\nIn the code chunk below, we use `corrplot.mixed()` from the **corrplot** package to visualize the correlation between vairables\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_vars.cor = cor(ict_derived[,12:17])\ncorrplot.mixed(cluster_vars.cor,\n         lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\nThe plot above shows that `COMPUTER_PR` and `INTERNET_PR` are highly correlated (coefficient of 0.87, shown as a very dark blue oval) This suggests that only one of these variables should be used in cluster analysis.\n\n# Hierarchical Cluster Analysis\n\nIn this section, we perform hierarchical cluster analysis which is done in a few steps steps\n\n## Selecting and extracting cluster variables\n\nThe code chunk below will be used to extract the clustering variables from the `shan_sf` dataframe. We have chosen to include `COMPUTER_PR` rather than `INTERNET_PR` for the cluster analysis\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_vars <- shan_sf %>%\n  st_set_geometry(NULL) %>%\n  select(\"TS.x\", \"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\", \"MPHONE_PR\", \"COMPUTER_PR\")\nhead(cluster_vars,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\n1    Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\n2    Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\n3    Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\n4   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\n5     Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\n6      Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\n7      Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\n8   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\n9  Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\n10   Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n\n\n:::\n:::\n\n\n\nThe next step is to change the row names or indices to the township names rather than the row numbers\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrow.names(cluster_vars) <- cluster_vars$\"TS.x\"\nhead(cluster_vars,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit     Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya     Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan     Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\nMabein       Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw         Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\nPekon         Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme     Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n\n\n:::\n:::\n\n\n\nWe see that the row numbers have been replaced with the township names, however, the township names are now duplicated. We solve this by using the code chunk below\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict <- select(cluster_vars, c(2:6))\nhead(shan_ict, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit   286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya   417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan   484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung  231.6499 541.7189   28.54454  249.4903    13.76255\nMabein    449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw     280.7624 611.6204   42.06478  408.7951    29.63160\nPekon     318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk  387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme   210.9548 601.1773   39.58267  372.4930    30.94709\n```\n\n\n:::\n:::\n\n\n\n## Data standardisation\n\nMultiple variables will usually have different range of values. If we use them as is for cluster analysis, then the clustering will be biased towards variables with larger values. It is useful to standardise the clustering variables to reduce the risk of this occuring.\n\n### Min-max standardisation\n\nThe code chunk below uses `normalize()` of **heatmaply** package to standardise the clustering variables using min-max method. We then use `summary()` to show that the ranges of each variable have transformed to \\[0,1\\]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict.std <- normalize(shan_ict)\nsummary(shan_ict.std)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    RADIO_PR          TV_PR          LLPHONE_PR       MPHONE_PR     \n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:0.2544   1st Qu.:0.4600   1st Qu.:0.1123   1st Qu.:0.2199  \n Median :0.4097   Median :0.5523   Median :0.1948   Median :0.3846  \n Mean   :0.4199   Mean   :0.5416   Mean   :0.2703   Mean   :0.3972  \n 3rd Qu.:0.5330   3rd Qu.:0.6750   3rd Qu.:0.3746   3rd Qu.:0.5608  \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n  COMPUTER_PR     \n Min.   :0.00000  \n 1st Qu.:0.09598  \n Median :0.17607  \n Mean   :0.23692  \n 3rd Qu.:0.29868  \n Max.   :1.00000  \n```\n\n\n:::\n:::\n\n\n\n### Z-score standardisation\n\nWe can perform z-score standardisation by using `scale()` of **Base R**. We use `describe()` of **psych** package to display some statistics of the standardised columns. These show that each of the variables have been transformed to have a mean of 1 and a standard deviation of 1\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict.z <- scale(shan_ict)\ndescribe(shan_ict.z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            vars  n mean sd median trimmed  mad   min  max range  skew kurtosis\nRADIO_PR       1 55    0  1  -0.04   -0.06 0.94 -1.85 2.55  4.40  0.48    -0.27\nTV_PR          2 55    0  1   0.05    0.04 0.78 -2.47 2.09  4.56 -0.38    -0.23\nLLPHONE_PR     3 55    0  1  -0.33   -0.15 0.68 -1.19 3.20  4.39  1.37     1.49\nMPHONE_PR      4 55    0  1  -0.05   -0.06 1.01 -1.58 2.40  3.98  0.48    -0.34\nCOMPUTER_PR    5 55    0  1  -0.26   -0.18 0.64 -1.03 3.31  4.34  1.80     2.96\n              se\nRADIO_PR    0.13\nTV_PR       0.13\nLLPHONE_PR  0.13\nMPHONE_PR   0.13\nCOMPUTER_PR 0.13\n```\n\n\n:::\n:::\n\n\n\n### Visualising the standardised clustering variables\n\nAside from viewing the statistics of the standardised variables, it is also good practice to visualise their distribution graphically.\n\nThe code chunk below produces histograms to show the `RADIO_PR` field without and with standardisation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- ggplot(data=ict_derived, aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\nAlternatively, we can view these as density plots using the code below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex09_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\n## Computing the proximity matrix\n\nxx\n",
    "supporting": [
      "Hands-On_Ex09_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}