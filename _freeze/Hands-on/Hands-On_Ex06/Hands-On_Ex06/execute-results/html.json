{
  "hash": "03310ec6aca441eeda94378555d8a8e1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Spatial Weights and Applications\"\nauthor: \"Federico Jose Rodriguez\"\ndate: \"Sep 15 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n\nIn this hands-on exercise, we learn how to compute spatial weights and spatially lagged in R using the **spdep** package.\n\nThis exercise is based on Chapter 8 of Dr Kam's online book which can be accessed [here](https://r4gdsa.netlify.app/ \"R for Geospatial Data Science and Analytics by Dr Kam\").\n\n# Getting Started\n\n## Data Sources\n\nData for this exercise are based on the Hunan county coming from two files:\n\n-   Hunan county boundary layer in ESRI shapefile format\n\n-   Hunan local development indicators for 2012 stored in a csv file\n\n## Installing and launching R packages\n\nThis exercise will make use of five R packages: **sf**, **tidyverse,** **tmap, and spdep**.\n\n-   **sf -** for importing, managing and processing vector-based geospatial data\n\n-   **tidyverse -** collection of packages for performing data importation, wrangling and visualization\n\n-   **tmap -** for plotting cartographic quality maps\n\n-   **spdep** - functions to create spatial weights\n\nThe code chunk below uses `p_load()` of **pacman** package to check if the packages are installed in the computer. It installs them first if they are not. It then loads them into R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse)\n```\n:::\n\n\n\n# Data Import and Preparation\n\n## Data Loading\n\nThe code chunk below uses `st_read()` of the **sf** package to load the Hunan shapefile into an R object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\Hands-on\\Hands-On_Ex06\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n\nThe following code chunk imports the second data source, a csv file, into an R object using `read_csv()` of the **readr** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\nWe can examine the contents of the two objects by calling them.\n\n::: panel-tabset\n#### hunan sf dataframe\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\nFirst 10 features:\n     NAME_2  ID_3    NAME_3   ENGTYPE_3 Shape_Leng Shape_Area    County\n1   Changde 21098   Anxiang      County   1.869074 0.10056190   Anxiang\n2   Changde 21100   Hanshou      County   2.360691 0.19978745   Hanshou\n3   Changde 21101    Jinshi County City   1.425620 0.05302413    Jinshi\n4   Changde 21102        Li      County   3.474325 0.18908121        Li\n5   Changde 21103     Linli      County   2.289506 0.11450357     Linli\n6   Changde 21104    Shimen      County   4.171918 0.37194707    Shimen\n7  Changsha 21109   Liuyang County City   4.060579 0.46016789   Liuyang\n8  Changsha 21110 Ningxiang      County   3.323754 0.26614198 Ningxiang\n9  Changsha 21111 Wangcheng      County   2.292093 0.13049161 Wangcheng\n10 Chenzhou 21112     Anren      County   2.240739 0.13343936     Anren\n                         geometry\n1  POLYGON ((112.0625 29.75523...\n2  POLYGON ((112.2288 29.11684...\n3  POLYGON ((111.8927 29.6013,...\n4  POLYGON ((111.3731 29.94649...\n5  POLYGON ((111.6324 29.76288...\n6  POLYGON ((110.8825 30.11675...\n7  POLYGON ((113.9905 28.5682,...\n8  POLYGON ((112.7181 28.38299...\n9  POLYGON ((112.7914 28.52688...\n10 POLYGON ((113.1757 26.82734...\n```\n\n\n:::\n:::\n\n\n\n#### hunan2012 dataframe\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 88 × 29\n   County    City   avg_wage deposite    FAI Gov_Rev Gov_Exp    GDP GDPPC    GIO\n   <chr>     <chr>     <dbl>    <dbl>  <dbl>   <dbl>   <dbl>  <dbl> <dbl>  <dbl>\n 1 Anhua     Yiyang    30544   10967   6832.    457.   2703  13225  14567  9277.\n 2 Anren     Chenz…    28058    4599.  6386.    221.   1455.  4941. 12761  4189.\n 3 Anxiang   Chang…    31935    5517.  3541     244.   1780. 12482  23667  5109.\n 4 Baojing   Hunan…    30843    2250   1005.    193.   1379.  4088. 14563  3624.\n 5 Chaling   Zhuzh…    31251    8241.  6508.    620.   1947  11585  20078  9158.\n 6 Changning Hengy…    28518   10860   7920     770.   2632. 19886  24418 37392 \n 7 Changsha  Chang…    54540   24332  33624    5350    7886. 88009  88656 51361 \n 8 Chengbu   Shaoy…    28597    2581.  1922.    161.   1192.  2570. 10132  1681.\n 9 Chenxi    Huaih…    33580    4990   5818.    460.   1724.  7755. 17026  6644.\n10 Cili      Zhang…    33099    8117.  4498.    500.   2306. 11378  18714  5843.\n# ℹ 78 more rows\n# ℹ 19 more variables: Loan <dbl>, NIPCR <dbl>, Bed <dbl>, Emp <dbl>,\n#   EmpR <dbl>, EmpRT <dbl>, Pri_Stu <dbl>, Sec_Stu <dbl>, Household <dbl>,\n#   Household_R <dbl>, NOIP <dbl>, Pop_R <dbl>, RSCG <dbl>, Pop_T <dbl>,\n#   Agri <dbl>, Service <dbl>, Disp_Inc <dbl>, RORP <dbl>, ROREmp <dbl>\n```\n\n\n:::\n:::\n\n\n:::\n\n## Performing relational join\n\nThe code chunk below will be used to import columns from `hunan2012` into `hunan` using `left_join()` of the **dplyr** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan,hunan2012)%>%\n  select(1:4, 7, 15)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(County)`\n```\n\n\n:::\n:::\n\n\n\n# Visualising Regional Development Indicator\n\nThe code chunk below uses **tmap** package to create two side by side maps of the basemap and a choropleth map based on the `GDPPC` attribute.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.5)\n\ngdppc <- qtm(hunan, \"GDPPC\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex06_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n# Computing Contiguity Spatial Weights\n\nThe `poly2nb()` of the **spdep** package computes contiguity weight matrices for a study area. This builds a neighbour list based on regions with contiguous boundaries. The function includes a `queen` argument which defaults to TRUE. This argument dictates whether the Queen criteria will be used in building a list of first order neighbours.\n\n## Computing (QUEEN) contiguity based neighbours\n\nThe code chunk below computes for a Queen contiguity weight matrix and displays a summary.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n\n\n:::\n:::\n\n\n\nThe output shows that:\n\n-   There are 88 units in the dataset.\n\n-   The most connected unit has 11 neighbours (and only one unit has 11 neighbours)\n\n-   There are two units with only one neighbour.\n\nThe resulting polygon object wm_q lists all neighboring polygons for each polygon. For example, the following code will show the neighbors of the first polygon:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  3  4 57 85\n```\n\n\n:::\n:::\n\n\n\nThis shows that there are 5 neighbors for the first polygon. The numbers denote the id of those neighbors as they are stored in `hunan`.\n\nWe can retrieve the names of those polygons or units using the code chunk below. The columns `County` and `NAME_3` contain the same value so either may be used to return the names\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$County[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Anxiang\"\n```\n\n\n:::\n\n```{.r .cell-code}\nhunan$NAME_3[c(2,3,4,57,85)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n```\n\n\n:::\n:::\n\n\n\nWe can retrieve the GDPPC of these countries using the code below (for polygon 1 and then for its five neighbours)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$GDPPC[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23667\n```\n\n\n:::\n\n```{.r .cell-code}\nhunan$GDPPC[wm_q[[1]]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20981 34592 24473 21311 22879\n```\n\n\n:::\n:::\n\n\n\nThe complete weight matrix can be displayed by using `str()`, i.e., `str(wm_q)`\n\n## Computing (ROOK) contiguity based neighbours\n\nThe code chunk below computes the Rook contiguity weight matrix by setting the `queen` argument to FALSE\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n```\n\n\n:::\n:::\n\n\n\nThe report shows a few differences compared to the earlier QUEEN contiguity matrix. The most connected area has 10 instead of 11 neighbors, and there are differences in the details from the number of nonzero links to the average number of links.\n\n## Visualizing contiguity weights\n\nIn this section, we introduce connectivity graphs which displays lines between neighboring points. As we are working with a polygon object at the moment, we would need to convert or define points to represent them first before attempting to build a connectivity graph. The most common method to do this is by choosing the centroid as the point for the polygon\n\n### Getting longitude and latitude of polygon centroids\n\nThe process is slightly complicated as we cannot immediately simply run `st_centroid()` on the object.\n\nFirst, we need to get the coordinates of the polygons in separate dataframe by using a mapping function. The code chunk below create a dataframe for the centroids along the longitude by using `st_centroid()` on the geometry longitude using double bracket notation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n```\n:::\n\n\n\nFor the latitudes, we use a similar code with the only difference being the index referenced by the double bracket notation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n```\n:::\n\n\n\nWe can then use `cbind()` to combine the two objects into a single object for the centroid locations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- cbind(longitude, latitude)\n```\n:::\n\n\n\nWe can confirm that the points are formatted correctly by checking the first few records with `head()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n```\n\n\n:::\n:::\n\n\n\n### Plotting Queen contiguity based neighbours map\n\nThe code below creates the connectivity graph based on the matrix in `wm_q`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex06_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n### Plotting Rook contiguity based neighbours map\n\nThe code below creates the connectivity graph based on the matrix in `wm_r`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex06_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n### Plotting Queen and Rook contiguity based neighbours map\n\nThe code below creates the connectivity graph for both queen and rook based contiguity and show theem side by side\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen Contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\nplot(hunan$geometry, border=\"lightgrey\", main=\"Rook Contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex06_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n# Computing distance-based neighbours\n\nIn this section, we will use `dnearneigh()` of the **spdep** package to derive the distance-based weight matrices. This function identifies neighbours by Euclidean distance based on a lower (`d1`) and upper (`d2`) bound based on the `bounds` argument.\n",
    "supporting": [
      "Hands-On_Ex06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}