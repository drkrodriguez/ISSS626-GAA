{
  "hash": "16f2e4a3aacf35f313436d006343b287",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Choropleth Mapping with R\"\nauthor: \"Federico Jose Rodriguez\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n\nFor this hands-on exercise, we learned how to plot choropleth maps by using an R package called **tmap**\n\nThis exercise is based on Chapter 2 of Dr Kam's online book which can be accessed [here](https://r4gdsa.netlify.app/ \"R for Geospatial Data Science and Analytics by Dr Kam\").\n\n# Getting Started\n\n## Data Sources\n\nThe exercise will use the following publicly available datasets:\n\n-   Master Plan 2014 Subzone Boundary from [data.gov.sg](https://beta.data.gov.sg/datasets/d_d14da225fccf921049ab64238ff473d9/view)\n\n-   Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 from [singstat.gov](https://www.singstat.gov.sg/-/media/files/find_data/population/statistical_tables/respopagesexfa2011to2020.ashx)\n\nThe first one is geospatial data and was also used in the previous hands-on exercise. The second source is for aspatial data but the `PA` and `SZ` fields in it allows geocoding into the shapefile.\n\n## Installing and launching R packages\n\nThis exercise will make use of three R packages: **sf**, **tidyverse** and **tmap**. We have already introduced the first two in the last exercise: **tidyverse** is a family of R packages used for data wrangling and visualization, while **sf** is used for importing, managing and processing geospatial data. Tidyverse is made up of multiple packages which include **tidyr** and **dplyr** which will be the specific packages where the functions we use will come from.\n\n**Tmap** stands for thematic map and will enable us to create the functional choropleth maps that go beyond the capabilities of `plot()`\n\nThe code chunk below uses `p_load()` of **pacman** package to check if the packages are installed in the computer. It installs them first if they are not. It then loads them into R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse, tmap)\ntmap_options(show.messages = FALSE)\n```\n:::\n\n\n\n# Data Loading and Preparation\n\n## Importing Geospatial Data into R\n\nWe first import `MP14_SUBZONE_WEB_PL` using `st_read()` function by providing the path and the layer name as parameters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\Hands-on\\Hands-On_Ex02\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\n\nWe can examine the contents by calling the dataframe like in the code chunk below. This function call only shows the first 10 features or rows of the dataframe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29...\n```\n\n\n:::\n:::\n\n\n\n## Importing Attribute Data into R\n\nOur remaining data is in a csv file which we will load into a dataframe called `popdata` using `read_csv()` which comes from the **readr** package that is included in **tidyverse**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata <- read_csv(\"data/aspatial/respopagesexfa2011to2020.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 738492 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, FA\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\nWe can quickly examine the data by calling the dataframe name. This shows that `popdata` consists of 738K records or rows with 7 attributes or columns.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 738,492 × 7\n   PA         SZ                     AG     Sex     FA              Pop  Time\n   <chr>      <chr>                  <chr>  <chr>   <chr>         <dbl> <dbl>\n 1 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   <= 60             0  2011\n 2 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   >60 to 80        10  2011\n 3 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   >80 to 100       30  2011\n 4 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   >100 to 120      80  2011\n 5 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   >120             20  2011\n 6 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males   Not Available     0  2011\n 7 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Females <= 60             0  2011\n 8 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Females >60 to 80        10  2011\n 9 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Females >80 to 100       40  2011\n10 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Females >100 to 120      90  2011\n# ℹ 738,482 more rows\n```\n\n\n:::\n:::\n\n\n\nWe will use the 2020 information from this to build a new data table `popdata2020` which includes the following variables:\n\n-   `PA` and `SZ` give information on the location (planning area and township)\n\n-   `YOUNG` is the population for those aged 0 to 24\n\n-   `ECONOMY ACTIVE` is the population for those aged 25 to 64\n\n-   `AGED` is the population for those aged 65 and above\n\n-   `TOTAL` is the total population across all age groups\n\n-   `DEPENDENCY` is the ratio between young and aged against the economy active group\n\n## Data Wrangling\n\nTo generate the required table from `popdata`, we will use `pivot_wider()` of **tidyr** package, `mutate()`, `filter()`, `group_by()` and `select()` of dplyr package. All of these are included in tidyverse.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup()%>%\n  pivot_wider(names_from=AG, \n              values_from=POP) %>%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %>%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+\nrowSums(.[13:15]))%>%\nmutate(`AGED`=rowSums(.[16:21])) %>%\nmutate(`TOTAL`=rowSums(.[3:21])) %>%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n:::\n\n\n\nWe can check that the transformation has been executed properly by displaying the new dataframe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 332 × 7\n   PA         SZ                   YOUNG `ECONOMY ACTIVE`  AGED TOTAL DEPENDENCY\n   <chr>      <chr>                <dbl>            <dbl> <dbl> <dbl>      <dbl>\n 1 Ang Mo Kio Ang Mo Kio Town Cen…  1440             2640   770  4850      0.837\n 2 Ang Mo Kio Cheng San             6660            15380  6080 28120      0.828\n 3 Ang Mo Kio Chong Boon            6150            13970  6450 26570      0.902\n 4 Ang Mo Kio Kebun Bahru           5500            12040  5080 22620      0.879\n 5 Ang Mo Kio Sembawang Hills       2130             3390  1270  6790      1.00 \n 6 Ang Mo Kio Shangri-La            3970             8430  3540 15940      0.891\n 7 Ang Mo Kio Tagore                2220             4160  1520  7900      0.899\n 8 Ang Mo Kio Townsville            4720            11430  5050 21200      0.855\n 9 Ang Mo Kio Yio Chu Kang             0                0     0     0    NaN    \n10 Ang Mo Kio Yio Chu Kang East     1190             2230   740  4160      0.865\n# ℹ 322 more rows\n```\n\n\n:::\n:::\n\n\n\n## Joining the attribute and geospatial data\n\nTo use this attribute data for our analysis, we need to join it with the geospatial data. The first step will be to convert the PA and SZ values to uppercase to make sure that they follow the same convention as the geospatial data. We use the `mutate_at()` function to apply this transformation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata2020 %>%\n  mutate_at(.vars = vars(PA, SZ), \n          .funs = list(toupper)) %>%\n  filter(`ECONOMY ACTIVE` > 0)\n```\n:::\n\n\n\nThe next step is to use left_join() from dplyr to merge the two tables using `SZ`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n```\n:::\n\n\n\nAs the left side is an sf dataframe, the resulting object is also an sf dataframe and we write this into a file to store for future use without rerunning all the transformations so far.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(mpsz_pop2020, \"data/mpszpop2020.rds\")\n```\n:::\n\n\n\n# Choropleth Mapping Geospatial Data using tmap\n\nChoropleth maping involves visualising enumeration units such as countries, provinces and counties using patterns or (graduated) colors.\n\nThere are two preparation approaches available using tmap:\n\n-   Using qtm() for quickly generating a thematic map\n\n-   Using tmap elements to highly customize and plot a map\n\n## Plotting a choropleth map quickly using `qtm()`\n\n`qtm()` is a convenient way to produce a thematic or choropleth map. It provides a good default or initial visualization.\n\nThe code chunk below draws a standard choropleth map using the values from `DEPENDENCY` as the fill.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\nThe `tmap_mode(\"plot\")` produces a static plot. To produce an interactive plot, `tmap_mode(\"view\")` should be used instead.\n\n`qtm()` takes the sf dataframe as its first argument. The `fill` argument defines which attribute to map.\n\n## Creating a choropleth map by using tmap's elements\n\nWhile convenient, the downside of `qtm()` is that it makes controlling the aesthetics of individual layers harder to control. Using tmap's drawing elements allows more customization, and allows the production of higher quality maps.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\nWe go through the different elements plotted and the respective functions below.\n\n### Drawing a base map\n\nThe basic building block of tmap is `tm_shape()` followed by one or more layer elements.\n\nIn the code chunk below, `tm_shape()` is used to define the input data and then `tm_polygons()` draws the planning subzone polygons.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n### Drawing a choropleth map using `tm_polygons()`\n\nThe code chunk below generates a choropleth map of the dependency ratio by planning subzone by passing `DEPENDENCY` to `tm_polygons()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\nA few points on `tm_polygons()`:\n\n-   The default binning used is called \"`pretty`\". We will go more into data classification methods later\n\n-   The default color scheme is `YlOrRd` (Yellow Orange Red) of ColorBrewer. We will also go more into color schemes later\n\n-   By default, missing values are shaded grey\n\n### Drawing a choropleth map using `tm_fill()` and `tm_border()`\n\n`tm_polygons()` is actually a wrapper of two other functions: `tm_fill()` and `tm_border()`.\n\n`tm_fill()` shades the polygons using the default color scheme. The code chunk below draws the choropleth map with just this element.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n`tm_borders()` adds the borders of the shapefile onto the map. We add this element to the previous code to produce a similar plot to the one generated with `tm_polygons()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1,  alpha = 1)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n`tm_borders()` has the following (optional) arguments:\n\n-   `alpha` defines the transparency and takes a value of 0 (totally transparent) to 1 (totally opaque)\n\n-   `col` defines the border colour\n\n-   `lwd` defines the border line width (default 1)\n\n-   `lty` defines the border line type (default solid)\n\n## Data Classification Methods on tmap\n\nData classification refers to grouping (a large number of) observations into data ranges or classes. **tmap** provides ten data classification methods which include: *fixed*, *sd*, *equal*, *pretty*, *quantile*, *kmeans*, *hclust*, *bclust*, *fisher*, and *jenks*\n\nThe data classification method can be defined by using the `style` argument in `tm_fill()` or `tm_polygons()`\n\n### Plotting choropleth maps with built-in classification methods\n\nThe code below produces a plot using *quantile* data classification with 5 classes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nThe code below produces a plot using *equal* data classification with 5 classes. Note that the previous chart produces evenly distributed classes, while this new chart has almost all but one zone in the first class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\nThe code below produces a plot using *jenks* data classification. By changing the `style` argument, the other data classification methods can be used.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n### Plotting Choropleth Maps with custom break\n\nThe builtin styles compute the class breaks or boundaries internally. To override this, the breakpoints can be set explicitly using the `breaks` argument of `tm_fill()`\n\nThe breaks defined will include the minimum and maximum. Therefore, to define n classes, n+1 breakpoints should be defined in the `breaks` argument.\n\nWe first run some descriptive statistics on `DEPENDENCY` before we define the breakpoints\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mpsz_pop2020$DEPENDENCY)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.7113  0.7926  0.8561  0.8786 19.0000      92 \n```\n\n\n:::\n:::\n\n\n\nBased on the distribution, say we define the breakpoints for five classes to be 0.6, 0.7, 0.8 and 0.9 to split. We need to include a minimum, 0, and a maximum, 20, for the `breaks` argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 20)) +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n## Colour Schemes\n\n**tmap** supports user-defined colour maps, and pre-defined colour maps from the **RColorBrewer** package.\n\n### Using ColourBrewer palette\n\nTo change the colour map, we assign a value to the `palette` argument of `tm_fill()` as shown in the code below\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\nThe choropleth map is shaded in blue where a darker shade corresponds to a higher value of `DEPENDENCY`. To reverse this behavior, we can add a \"-\" prefix to the passed value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Blues\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\n## Map Layouts\n\nMap layout refers to the combination of all map elements into a cohesive map. Aside from the objects, the other elements include the title, the scale bar, a compass, margins and aspect ratios.\n\n### Map Legend\n\nSeveral options are provided to adjust the placement, format and appearance of the legend.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n### Map Style\n\nA wide variety of layout settings can be changed by calling `tmap_style()`\n\nThe codeblock below shows the map using the *classic* style.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n### Cartographic Furniture\n\n**tmap** provides options to add other elements like a compass, scale, and grid lines. In the code chunk below, `tm_compass()`, `tm_scale_bar()` and `tm_grid()` are used to add these elements.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\nNote that the above map still uses the *classic* style. To revert to the default style, use the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_style(\"white\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap style set to \"white\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n```\n\n\n:::\n:::\n\n\n\n## Drawing Small Multiple Choropleth Maps\n\n**Small multiple maps** or **facet maps** are composed of multiple maps arranged side-by-side. (in a grid, stacked vertically, lined up) Small multiple maps allow visualization of how spatial relationships change with respect to one variable. (e.g., time)\n\nThere are three ways to define small multiples in **tmap**:\n\n-   by assigning multiple values to at least one aesthetic argument,\n\n-   by defining a group-by variable in `tm_facets()`, and\n\n-   by creating multiple stand-alone maps with `tmap_arrange()`\n\n### Assigning multiple values to at least one of the aesthetic arguments\n\nIn the code below, small multiple maps are created by passing a list of (numeric) columns as the `col` argument of `tm_fill()` Each map depicts a different column or attribute.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap style set to \"white\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\nIn the next code, two parameters are passed to `palette` argument to result to different colour maps for the each small multiple.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\n### By defining a group-by variable in tm_facets()\n\nIn the code below, a small multiple of each region is created by using `tm_facets()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.units=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n### By creating multiple stand-alone maps and using `tmap_arrange()`\n\nIn the following code, two maps are defined individually and then displayed side by side using `tmap_arrange()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\n## Mapping Spatial Objects Meeting Selection Criterion\n\nInstead of using small multiples to look at a particular subset of the data, you can also use a selection criteria or a mask to only map objects meeting a particular condition. The code below produces a map for only the Central Region.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-On_Ex02_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-On_Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}