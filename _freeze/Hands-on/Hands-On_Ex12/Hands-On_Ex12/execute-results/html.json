{
  "hash": "3ac15537c8c741047fa9f2b86f9371bc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Modelling Geographic Accessibility\"\nauthor: \"Federico Jose Rodriguez\"\ndate: \"Oct 27 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n\nIn this hands-on exercise, we model geographic accessibility using R.\n\nThis exercise is based on Chapter 17 of Dr Kam's online book which can be accessed [here](https://r4gdsa.netlify.app/ \"R for Geospatial Data Science and Analytics by Dr Kam\").\n\n# Getting Started\n\n## Data Sources\n\nThe data for this exercise comes in the form of four files:\n\n-   2014 Master Plan Planning subzone boundary in shapefile format sourced from data.gov.sg\n\n-   Singapore GIS data with hexagons of 250m radius generated by using `st_make_grid()` of the **sf** package\n\n-   Location of eldercare centres sourced from data.gov.sg and in shapefile format\n\n-   A distance matrix in csv format from the hexagons to the eldercare centres. The data also contains fields for the entry, exit and network costs which give the distance between roads and the hexagon, between roads and eldercare centres, and between the network points of the hexagon and eldercare centre.\n\nAside from the first dataset, the balance are already processed datasets c/o Prof Kam to be used by his students for this exercise.\n\n## Installing and launching R packages\n\nThis exercise will make use of six R packages. For this exercise, we will use **spatialAcc** which is used to model geographic accessibility.\n\nThe code chunk below uses `p_load()` of **pacman** package to check if the packages are installed in the computer. It installs them first if they are not. It then loads them into R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, SpatialAcc, sf, \n               ggstatsplot, reshape2,\n               tidyverse)\n```\n:::\n\n\n\n# Geospatial Data Wrangling\n\n## Importing geospatial data\n\nWe use `st_read()` of sf package to load the three geospatial datasets into R.\n\n::: panel-tabset\n#### Loading Planning Subzone\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\Hands-on\\Hands-On_Ex12\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\n\n#### Loading Hexagons\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `hexagons' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\Hands-on\\Hands-On_Ex12\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n\n\n#### Loading Eldercare Centre Location\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ELDERCARE' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\Hands-on\\Hands-On_Ex12\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n\n:::\n\nThe outputs show that all the objects are in **sf** format. The object `mpsz` is both in multipolygon class and currently does not have EPSG information.\n\n## Updating CRS information\n\nThe code chunk below assigns and ensures that all objects have the same EPSG code of 3414.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_transform(mpsz, 3414)\neldercare <- st_transform(eldercare, 3414)\nhexagons <- st_transform(hexagons, 3414)\n```\n:::\n\n\n\nWe can then use `st_crs()` of sf package to confirm the CRS information of an object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n\n\n## Cleaning and updating attribute fields of the geospatial data\n\nIf we inspect the last two objects, we see that there are a number of redundant or unnecessary fields. We use the code chunk below to only keep the necessary ones using `select()`. We also add a new field called capacity to both objects using `mutate()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n```\n:::\n\n\n\nFor this exercise we use a dummy value of 100 for the capacity, but, in practice, this number needs to be updated with the actual capacity of the location.\n\n# Aspatial Data Handling and Wrangling\n\n## Importing the Distance Matrix\n\nThe code chunk below uses `read_csv()` to load the distance matrix into R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 375000 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (6): origin_id, destination_id, entry_cost, network_cost, exit_cost, tot...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\nWe can inspect the object using `head()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ODMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  origin_id destination_id entry_cost network_cost exit_cost total_cost\n      <dbl>          <dbl>      <dbl>        <dbl>     <dbl>      <dbl>\n1         1              1       668.       19847.      47.6     20562.\n2         1              2       668.       45027.      31.9     45727.\n3         1              3       668.       17644.     173.      18486.\n4         1              4       668.       36010.      92.2     36770.\n5         1              5       668.       31068.      64.6     31801.\n6         1              6       668.       31195.     117.      31980.\n```\n\n\n:::\n:::\n\n\n\n## Tidying the distance matrix\n\nBased on our inspection, we see that the distance matrix is not yet in the typical matrix format where the origin is on one axis and the destination is on another. Instead, the origins and the destinations are in their respective columns and there are fields for the distances.\n\nIn order to transform the object into matrix format, we use `spread()` of **tidyr** in the code chunk below. `pivot_wider()` can also be used to achieve the same result\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  spread(destination_id, total_cost)%>%\n  select(c(-c('origin_id')))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(distmat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\nThe matrix is still in dataframe format and is in meters. We use the code below to convert it to km and turn it into a matrix.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat_km <- as.matrix(distmat/1000)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(distmat_km)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\n\n# Modelling and Visualizing Accessibility using Hansen Method\n\n## Computing Hansen Accessibility\n\nTo compute for the Hansen accessibility we use `ac()` of the **SpatialAcc** package. The code chunk below does this and also uses `data.frame()` to convert the output into dataframe format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3,125\nColumns: 1\n$ ac.hexagons.demand..eldercare.capacity..distmat_km..power...2.. <dbl> 1.6483…\n```\n\n\n:::\n:::\n\n\n\nWe see that the function returns one field and its default field name is a unreadable. We can fix this by assigning a new name to `colnames()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(acc_Hansen) <- \"accHansen\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3,125\nColumns: 1\n$ accHansen <dbl> 1.648313e-14, 1.096143e-16, 3.865857e-17, 1.482856e-17, 1.05…\n```\n\n\n:::\n:::\n\n\n\nWe then convert the accessibility measure to tibble format and then bind it with the hexagon data frame using the two lines of code in the following code chunk\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- tibble::as_tibble(acc_Hansen)\n\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n```\n:::\n\n\n\n## Visualising Hansen's Accessibility\n\nWe first extract the extent of the `hexagons` object using `st_bbox()` of sf package\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapex <- st_bbox(hexagons)\n```\n:::\n\n\n\nWe use **tmap** package in the code chunk below to create a visualization of the accessibility of eldercare centres across Singapore using Hansen method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex12_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n## Statistical graphical representation\n\nWe can compare the distribution of the accessibility values (using Hansen method) across planning regions.\n\nFirst, we need to include the planning region field into `hexagon_Hansen` object by using `st_join()` in the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\n\nWe then use `ggplot()` to produce a box plot of the accessibility value by planning region.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_Hansen, \n       aes(y = log(accHansen), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-On_Ex12_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n# Modelling and Visualizing Accessibility using KD2SFCA Method\n\n## Computing KD2SFCA Accessibility\n\nTo compute for the KD2SFCA accessibility we use `ac()` of the **SpatialAcc** package. The code chunk below does this and also uses `data.frame()` to convert the output into dataframe format. Compared to the previous section, we use a different value for the family argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            d0 = 50,\n                            power = 2, \n                            family = \"KD2SFCA\"))\n\ncolnames(acc_KD2SFCA) <- \"accKD2SFCA\"\nacc_KD2SFCA <- tibble::as_tibble(acc_KD2SFCA)\nhexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(acc_KD2SFCA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3,125\nColumns: 1\n$ accKD2SFCA <dbl> 1.745751e-149, 1.849596e-192, 4.442757e-202, 3.938161e-211,…\n```\n\n\n:::\n:::\n\n\n\nThe object already includes updating the measure's column name and binds the measure values to the hexagon sf dataframe.\n\n## Visualising KD2SFCA's Accessibility\n\nWe again use **tmap** package in the code chunk below to create a visualization of the accessibility of eldercare centres across Singapore using KD2SFCA method.Note that we reuse the `mapex` object from the previous section.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_KD2SFCA,\n         bbox = mapex) + \n  tm_fill(col = \"accKD2SFCA\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: KD2SFCA method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex12_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n## Statistical graphical representation\n\nWe can compare the distribution of the accessibility values (using Hansen method) across planning regions.\n\nFirst, we need to include the planning region field into the last object by using `st_join()` in the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\n\nWe then use `ggplot()` to produce a box plot of the accessibility value by planning region.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_KD2SFCA, \n       aes(y = accKD2SFCA, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-On_Ex12_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\n# Modelling and Visualizing Accessibility using SAM Method\n\n## Computing SAM's Accessibility\n\nTo compute for the SAM accessibility we use `ac()` of the **SpatialAcc** package. The code chunk below does this and also uses `data.frame()` to convert the output into dataframe format. Compared to the previous section, we use a different value for the family argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_SAM <- data.frame(ac(hexagons$demand,\n                         eldercare$capacity,\n                         distmat_km, \n                         d0 = 50,\n                         power = 2, \n                         family = \"SAM\"))\n\ncolnames(acc_SAM) <- \"accSAM\"\nacc_SAM <- tibble::as_tibble(acc_SAM)\nhexagon_SAM <- bind_cols(hexagons, acc_SAM)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(acc_SAM)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3,125\nColumns: 1\n$ accSAM <dbl> 0.11941792, 0.10101549, 0.09775876, 0.09490965, 0.09391923, 0.0…\n```\n\n\n:::\n:::\n\n\n\nThe object already includes updating the measure's column name and binds the measure values to the hexagon sf dataframe.\n\n## Visualising SAM's Accessibility\n\nWe again use **tmap** package in the code chunk below to create a visualization of the accessibility of eldercare centres across Singapore using SAM method. Note that we reuse the `mapex` object from the previous section.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_SAM,\n         bbox = mapex) + \n  tm_fill(col = \"accSAM\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: SAM method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 3),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex12_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n## Statistical graphical representation\n\nWe can compare the distribution of the accessibility values (using Hansen method) across planning regions.\n\nFirst, we need to include the planning region field into the last object by using `st_join()` in the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_SAM <- st_join(hexagon_SAM, mpsz, \n                       join = st_intersects)\n```\n:::\n\n\n\nWe then use `ggplot()` to produce a box plot of the accessibility value by planning region.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_SAM, \n       aes(y = accSAM, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-On_Ex12_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n\nThe boxes are not clear due to the outliers. Note that we can hide outliers in ggplot boxplots using the `outlier.shape` argument. In addition, the y-axis needs to be reset using `coord_cartesian()` as removing the outliers does not aautomatically adjust the axis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_SAM, \n       aes(y = accSAM, \n           x= REGION_N)) +\n  geom_boxplot(outlier.shape = NA) +\n  coord_cartesian(ylim = c(0,8)) + \n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-On_Ex12_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-On_Ex12_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}