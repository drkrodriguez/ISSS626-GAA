{
  "hash": "7e86dd3f27453bfabe6f3666bb2cec81",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Global and Local Measures of Spatial Autocorrelation\"\nauthor: \"Federico Jose Rodriguez\"\ndate: \"Sep 23 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n\nIn this exercise, we are introduced to the **sfdep** package which is a wrapper on **spdep** and enables us to work directly with sf objects. It is also written in such a way to fully take advantage of the **tidyverse** framework.\n\n# Importing and Loading packages\n\nThis exercise will make use of five R packages: **sf**, **tidyverse,** **tmap, and sfdep**.\n\n-   **sf -** for importing, managing and processing vector-based geospatial data\n\n-   **tidyverse -** collection of packages for performing data importation, wrangling and visualization\n\n-   **tmap -** for plotting cartographic quality maps\n\n-   **sfdep** - functions to create spatial weights, autocorrelation statistics for sf objects\n\nThe code chunk below uses `p_load()` of **pacman** package to check if the packages are installed in the computer. It installs them first if they are not. It then loads them into R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse)\n```\n:::\n\n\n\nWe also define a random seed value for repeatability of any simulation results.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n\n# Data Import and Preparation\n\nFor this exercise, we will make use of the Hunan administrative map shapefile and economic indicators csv that we have used in the hands-on exercises.\n\nThe code chunk below uses `st_read()` of the **sf** package to load the Hunan shapefile into an R object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\In-class\\In-class_Ex04\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n\nWe then use the code chunk below to load the csv file with the indicators into R using `read_csv()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n## Data Preparation\n\nWe then update the first object, which is of sf type, by adding in the economic indicators from the second object using `left_join()` as in the code chunk below\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan,hunan2012) %>%\n  select(1:4, 7, 15)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(County)`\n```\n\n\n:::\n:::\n\n\n\nIf we check the contents of `hunan` using `head()`, we see that it now includes a column `GDDPPC`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3  County GDPPC\n1 Changde 21098 Anxiang      County Anxiang 23667\n2 Changde 21100 Hanshou      County Hanshou 20981\n3 Changde 21101  Jinshi County City  Jinshi 34592\n4 Changde 21102      Li      County      Li 24473\n5 Changde 21103   Linli      County   Linli 25554\n6 Changde 21104  Shimen      County  Shimen 27137\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n```\n\n\n:::\n:::\n\n\n\n## Visualization of the Development Indicator\n\nBefore we move to the main analyses, we can visualize the distribution of GCPPC by using **tmap** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Hunan GDP per capita\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex04_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n# Global Measures of Spatial Autocorrelation\n\n## Step 1: Computing Deriving Queen's Contiguity Weights\n\nWe use the code chunk below to compute for the contiguity weight matrix using Queen's criterion.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- hunan %>%\n  mutate(nb = st_contiguity(geometry),\n         wt = st_weights(nb,\n                         style=\"W\"),\n         .before=1)\n```\n:::\n\n\n\nThe `st_weights()` function allows three arguments:\n\n1.  `nb` -\n2.  `style` -\n3.  `allow_zero` -\n\n## Step 2a: Performing Global Moran's I Test\n\nThe Global Moran's I test can be performed using `global_moran_test()` of the **sfdep** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n\nAt α=0.05, the test shows that we reject a null hypothesis that the GDPPC values are randomly distributed. As the test statistic is above 0, then the data is showing signs of clustering.\n\n## Step 2b: Performing Global Moran's I Permutation Test\n\nMonte Carlo simulation on the (Global Moran's I) statistic is performed using `global_moran_perm()` of the **sfdep** package. The code chunk below performs 100 simulations (`nsim` + 1)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim = 99)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n\n\n:::\n:::\n\n\n\nWe get consistent result with the one-time run, but with a lower p-value. (and higher confidence)\n\n# Local Measures of Spatial Autocorrelation\n\nAs we see that there are presence of clusters, the next step is to use local measure's of spatial autocorrelation, or local indicators of spatial association, LISA, to identify where the clusters are.\n\n## Computing Local Moran's I\n\nWe compute for the local Moran's I statistic for each unit by using `local_moran()` of **sfdep** package. The `unnest()` function expands the elements of list `local_moran` as separate columns in the `lisa` object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa <- wm_q %>%\n  mutate(local_moran = local_moran(\n    GDPPC, nb, wt, nsim = 99),\n    .before = 1) %>%\n  unnest(local_moran)\n```\n:::\n\n\n\nWe can examine the columns of `lisa` using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(lisa)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 88\nColumns: 21\n$ ii           <dbl> -1.468468e-03, 2.587817e-02, -1.198765e-02, 1.022468e-03,…\n$ eii          <dbl> 0.0017692414, 0.0064149158, -0.0374068734, -0.0000348833,…\n$ var_ii       <dbl> 4.179959e-04, 1.051040e-02, 1.020555e-01, 4.367565e-06, 1…\n$ z_ii         <dbl> -0.15836231, 0.18984794, 0.07956903, 0.50594053, 0.448752…\n$ p_ii         <dbl> 0.874171311, 0.849428289, 0.936580031, 0.612898396, 0.653…\n$ p_ii_sim     <dbl> 0.82, 0.96, 0.76, 0.64, 0.50, 0.82, 0.08, 0.08, 0.02, 0.2…\n$ p_folded_sim <dbl> 0.41, 0.48, 0.38, 0.32, 0.25, 0.41, 0.04, 0.04, 0.01, 0.1…\n$ skewness     <dbl> -0.8122108, -1.0905447, 0.8239085, 1.0401038, 1.6357304, …\n$ kurtosis     <dbl> 0.651875433, 1.889177462, 0.046095140, 1.613439800, 3.960…\n$ mean         <fct> Low-High, Low-Low, High-Low, High-High, High-High, High-L…\n$ median       <fct> High-High, High-High, High-High, High-High, High-High, Hi…\n$ pysal        <fct> Low-High, Low-Low, High-Low, High-High, High-High, High-L…\n$ nb           <nb> <2, 3, 4, 57, 85>, <1, 57, 58, 78, 85>, <1, 4, 5, 85>, <1,…\n$ wt           <list> <0.2, 0.2, 0.2, 0.2, 0.2>, <0.2, 0.2, 0.2, 0.2, 0.2>, <0…\n$ NAME_2       <chr> \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"C…\n$ ID_3         <int> 21098, 21100, 21101, 21102, 21103, 21104, 21109, 21110, 2…\n$ NAME_3       <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", …\n$ ENGTYPE_3    <chr> \"County\", \"County\", \"County City\", \"County\", \"County\", \"C…\n$ County       <chr> \"Anxiang\", \"Hanshou\", \"Jinshi\", \"Li\", \"Linli\", \"Shimen\", …\n$ GDPPC        <dbl> 23667, 20981, 34592, 24473, 25554, 27137, 63118, 62202, 7…\n$ geometry     <POLYGON [°]> POLYGON ((112.0625 29.75523..., POLYGON ((112.228…\n```\n\n\n:::\n:::\n\n\n\nThe `local_moran()` function generated 12 columns– which are the first twelve in the `lisa` dataframe. Key columns are:\n\n-   `ii` - local Moran i statistic\n\n-   `p_ii_sim` - p value from simulation\n\n-   For the clustering / outlier classification, there are three options in different columns: `mean`, `median`, `pysal`.\n\n## Visualising Local Moran I's\n\nThe code chunk below prepares a choropleth map of the statistic in the `ii` and the `p_ii_sim` field\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(lisa) +\n  tm_fill(c(\"ii\", \"p_ii_sim\"), title = c(\"Local Moran's I\",\"P Value\")) +\n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(\n    main.title = \"Local Moran's I and P-values\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nVariable(s) \"ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-class_Ex04_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n## LISA map\n\nA LISA map is a categorical map showing outliers and clusters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig <- lisa %>%\n  filter(p_ii < 0.05)\n\ntm_shape(lisa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(lisa_sig) +\n  tm_fill(\"mean\") +\n  tm_borders(alpha = 0.4)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](In-class_Ex04_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n## Computing Local Gi\\* Statistics\n\nThe code below computes the weight matrix using inverse distance.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_idw <- hunan %>%\n  mutate(nb = st_contiguity(geometry),\n         wts = st_inverse_distance(nb, geometry,\n                                   scale = 1,\n                                   alpha = 1),\n         .before=1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n! Polygon provided. Using point on surface.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `stopifnot()`.\nℹ In argument: `wts = st_inverse_distance(nb, geometry, scale = 1, alpha = 1)`.\nCaused by warning in `st_point_on_surface.sfc()`:\n! st_point_on_surface may not give correct results for longitude/latitude data\n```\n\n\n:::\n:::\n\n\n\nWe then compute the local Gi\\* by using the code below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA <- wm_idw %>%\n  mutate(local_Gi = local_gstar_perm(\n    GDPPC, nb, wt, nsim = 99),\n    .before = 1) %>%\n  unnest(local_Gi)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 88 features and 18 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n# A tibble: 88 × 19\n   gi_star cluster   e_gi     var_gi std_dev p_value p_sim p_folded_sim skewness\n     <dbl> <fct>    <dbl>      <dbl>   <dbl>   <dbl> <dbl>        <dbl>    <dbl>\n 1  0.0416 Low     0.0114 0.00000641  0.0493 9.61e-1  0.7          0.35    0.875\n 2 -0.333  Low     0.0106 0.00000384 -0.0941 9.25e-1  1            0.5     0.661\n 3  0.281  High    0.0126 0.00000751 -0.151  8.80e-1  0.9          0.45    0.640\n 4  0.411  High    0.0118 0.00000922  0.264  7.92e-1  0.6          0.3     0.853\n 5  0.387  High    0.0115 0.00000956  0.339  7.34e-1  0.62         0.31    1.07 \n 6 -0.368  High    0.0118 0.00000591 -0.583  5.60e-1  0.72         0.36    0.594\n 7  3.56   High    0.0151 0.00000731  2.61   9.01e-3  0.06         0.03    1.09 \n 8  2.52   High    0.0136 0.00000614  1.49   1.35e-1  0.2          0.1     1.12 \n 9  4.56   High    0.0144 0.00000584  3.53   4.17e-4  0.04         0.02    1.23 \n10  1.16   Low     0.0104 0.00000370  1.82   6.86e-2  0.12         0.06    0.416\n# ℹ 78 more rows\n# ℹ 10 more variables: kurtosis <dbl>, nb <nb>, wts <list>, NAME_2 <chr>,\n#   ID_3 <int>, NAME_3 <chr>, ENGTYPE_3 <chr>, County <chr>, GDPPC <dbl>,\n#   geometry <POLYGON [°]>\n```\n\n\n:::\n:::\n\n\n\n## Visualising Gi\\*\n\nThe code chunk\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(HCSA) +\n  tm_polygons()+\ntm_shape(filter(HCSA,p_sim < 0.05)) +\n  tm_polygons(c(\"cluster\",\"p_sim\"), title=c(\"Cluster\",\"P-Value\"))\n```\n\n::: {.cell-output-display}\n![](In-class_Ex04_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "In-class_Ex04_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}