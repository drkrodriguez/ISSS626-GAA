{
  "hash": "d4fb64930630ef2fc2d57d9b61403f03",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Geographic Accessibility\"\nauthor: \"Federico Jose Rodriguez\"\ndate: \"Oct 28 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n\nWe revise the hands-on exercise and look at the calibration in a bit more detail.\n\n# Getting Started\n\n## Data Sources\n\nThe data for this exercise comes in the form of four files:\n\n-   2014 Master Plan Planning subzone boundary in shapefile format sourced from data.gov.sg\n\n-   Singapore GIS data with hexagons of 250m radius generated by using `st_make_grid()` of the **sf** package\n\n-   Location of eldercare centres sourced from data.gov.sg and in shapefile format\n\n-   A distance matrix in csv format from the hexagons to the eldercare centres. The data also contains fields for the entry, exit and network costs which give the distance between roads and the hexagon, between roads and eldercare centres, and between the network points of the hexagon and eldercare centre.\n\nAside from the first dataset, the balance are already processed datasets c/o Prof Kam to be used by his students for this exercise.\n\n## Installing and launching R packages\n\nThis exercise will load the same R packages. The package **ggstatsplot** will also be used more in this in-class exercise.\n\nThe code chunk below uses `p_load()` of **pacman** package to check if the packages are installed in the computer. It installs them first if they are not. It then loads them into R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, SpatialAcc, sf, \n               ggstatsplot, reshape2,\n               tidyverse)\n```\n:::\n\n\n\n# Geospatial Data Wrangling\n\n## Importing geospatial data\n\nWe use `st_read()` of sf package to load the three geospatial datasets into R.\n\n::: panel-tabset\n#### Loading Planning Subzone\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\In-class\\In-class_Ex08\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\n\n#### Loading Hexagons\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `hexagons' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\In-class\\In-class_Ex08\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n\n\n#### Loading Eldercare Centre Location\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ELDERCARE' from data source \n  `C:\\drkrodriguez\\ISSS626-GAA\\In-class\\In-class_Ex08\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n\n:::\n\nThe outputs show that all the objects are in **sf** format. The object `mpsz` is both in multipolygon class and currently does not have EPSG information.\n\n## Updating CRS information\n\nThe code chunk below assigns and ensures that all objects have the same EPSG code of 3414.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_transform(mpsz, 3414)\neldercare <- st_transform(eldercare, 3414)\nhexagons <- st_transform(hexagons, 3414)\n```\n:::\n\n\n\n## Cleaning and updating attribute fields of the geospatial data\n\nIf we inspect the last two objects, we see that there are a number of redundant or unnecessary fields. We use the code chunk below to only keep the necessary ones using `select()`. We also add a new field called capacity to both objects using `mutate()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n```\n:::\n\n\n\nFor this exercise we use a dummy value of 100 for the capacity, but, in practice, this number needs to be updated with the actual capacity of the location.\n\n\n# Aspatial Data Handling and Wrangling\n\n## Importing the Distance Matrix\n\nThe code chunk below uses `read_csv()` to load the distance matrix into R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 375000 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (6): origin_id, destination_id, entry_cost, network_cost, exit_cost, tot...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nThe data is already preprocessed, but if one wants to generate the distances themselves, they may use the package r5r.\n\nWe can inspect the object using `head()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ODMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  origin_id destination_id entry_cost network_cost exit_cost total_cost\n      <dbl>          <dbl>      <dbl>        <dbl>     <dbl>      <dbl>\n1         1              1       668.       19847.      47.6     20562.\n2         1              2       668.       45027.      31.9     45727.\n3         1              3       668.       17644.     173.      18486.\n4         1              4       668.       36010.      92.2     36770.\n5         1              5       668.       31068.      64.6     31801.\n6         1              6       668.       31195.     117.      31980.\n```\n\n\n:::\n:::\n\n\n\n## Tidying the distance matrix\n\nBased on our inspection, we see that the distance matrix is not yet in the typical matrix format where the origin is on one axis and the destination is on another. Instead, the origins and the destinations are in their respective columns and there are fields for the distances.\n\nIn order to transform the object into matrix format, we use `spread()` of **tidyr** in the code chunk below. `pivot_wider()` can also be used to achieve the same result\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  spread(destination_id, total_cost)%>%\n  select(c(-c('origin_id')))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(distmat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\nThe matrix is still in dataframe format and is in meters. We use the code below to convert it to km and turn it into a matrix.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat_km <- as.matrix(distmat/1000)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(distmat_km)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n# Modelling and Visualizing Accessibility using Hansen Method\n\n## Computing Hansen Accessibility\n\nTo compute for the Hansen accessibility we use `ac()` of the **SpatialAcc** package. The code chunk below does this and also uses `data.frame()` to convert the output into dataframe format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3,125\nColumns: 1\n$ ac.hexagons.demand..eldercare.capacity..distmat_km..power...2.. <dbl> 1.6483…\n```\n\n\n:::\n:::\n\n\n\nWe see that the function returns one field and its default field name is a unreadable. We can fix this by assigning a new name to `colnames()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(acc_Hansen) <- \"accHansen\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3,125\nColumns: 1\n$ accHansen <dbl> 1.648313e-14, 1.096143e-16, 3.865857e-17, 1.482856e-17, 1.05…\n```\n\n\n:::\n:::\n\n\n\nWe then convert the accessibility measure to tibble format and then bind it with the hexagon data frame using the two lines of code in the following code chunk\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- tibble::as_tibble(acc_Hansen)\n\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n```\n:::\n\n\n\n## Visualising Hansen's Accessibility\n\nWe first extract the extent of the `hexagons` object using `st_bbox()` of sf package\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapex <- st_bbox(hexagons)\n```\n:::\n\n\n\nWe use **tmap** package in the code chunk below to create a visualization of the accessibility of eldercare centres across Singapore using Hansen method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex08_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n## Statistical graphical representation\n\nWe can compare the distribution of the accessibility values (using Hansen method) across planning regions.\n\nFirst, we need to include the planning region field into `hexagon_Hansen` object by using `st_join()` in the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\n\nWe then use `ggbetweenstats()` to produce a more analytic statistical visual.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggbetweenstats(data = hexagon_Hansen,\n               x= REGION_N,\n               y = accHansen,\n               type = \"p\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex08_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "In-class_Ex08_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}