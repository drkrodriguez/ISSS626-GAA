{
  "hash": "b221d31b498c6864f900a710cda99eb9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Geospatially Weighted Forecasting Model\"\nauthor: \"Federico Jose Rodriguez\"\ndate: \"Oct 21 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n\nIn this in-class exercise, we go through some of the steps to work on HDB data and then revise the hands-on exercise.\n\n# Preparing the HDB data\n\n## Loading Packages\n\nThe following code chunk loads five packages for this exercise. We use the three of them for the first time:\n\n-   **httr** - allows us to let R \"talk to http\"\n\n-   **rvest** - is used for crawling websites (https://rvest.tidyverse.org)\n\n-   **jsonlite** - to be able to work with the crawled data which is returned in JSON format\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, sf, httr, jsonlite, rvest)\n```\n:::\n\n\n\n## Loading and Preparing Aspatial Data\n\nWe use the following code chunk to load the latest HDB resale prices from [data.gov.sg](https://data.gov.sg/datasets/d_8b84c4ee58e3cfc0ece0d773c8ca6abc/view). For the problem, we are only concerned with 2023 information and onwards, so we apply a filter in the pipeline.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale <- read_csv(\"data/aspatial/resale.csv\") %>%\n  filter(month >= \"2023-01\" & month <= \"2024-09\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 192234 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (8): month, town, flat_type, block, street_name, storey_range, flat_mode...\ndbl (3): floor_area_sqm, lease_commence_date, resale_price\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\nWe can take a look at the data using `head()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(resale)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 11\n  month town  flat_type block street_name storey_range floor_area_sqm flat_model\n  <chr> <chr> <chr>     <chr> <chr>       <chr>                 <dbl> <chr>     \n1 2023… ANG … 2 ROOM    406   ANG MO KIO… 01 TO 03                 44 Improved  \n2 2023… ANG … 2 ROOM    323   ANG MO KIO… 04 TO 06                 49 Improved  \n3 2023… ANG … 2 ROOM    314   ANG MO KIO… 04 TO 06                 44 Improved  \n4 2023… ANG … 2 ROOM    314   ANG MO KIO… 07 TO 09                 44 Improved  \n5 2023… ANG … 2 ROOM    170   ANG MO KIO… 01 TO 03                 45 Improved  \n6 2023… ANG … 3 ROOM    225   ANG MO KIO… 04 TO 06                 67 New Gener…\n# ℹ 3 more variables: lease_commence_date <dbl>, remaining_lease <chr>,\n#   resale_price <dbl>\n```\n\n\n:::\n:::\n\n\n\nIt is worth noting that there are no exact locations readily present in the data set. There are towns and block numbers, but there are no postcodes.\n\nThe code chunk below produces an address column, and remaining lease columns. We produce the address column to try to use it for reverse geocoding later.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_tidy <- resale %>%\n  mutate(address = paste(block,street_name)) %>%\n  mutate(remaining_lease_yr = as.integer(\n    str_sub(remaining_lease, 0, 2)))%>%\n  mutate(remaining_lease_mth = as.integer(\n    str_sub(remaining_lease, 9, 11)))\n```\n:::\n\n\n\nWe will only demonstrate geocoding via API and web crawling, we limit the data to just a single month. (Sept 2024)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_selected <- resale_tidy %>%\n  filter(month == \"2024-09\")\n```\n:::\n\n\n\nSince we only need to pass an address once for reverse geocoding, we reduce the data to unique addresses and then sort them.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_list <- sort(unique(resale_selected$address))\n```\n:::\n\n\n\nWith this list, we can crawl onemap.gov.sg to perform the reverse geocoding for each address on at a time. It passes each address into the search field one at a time and then appends the first nonNIL result into `postal_coords` The following code chunk creates the function to perform this.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_coords <- function(add_list){\n  \n  # Create a data frame to store all retrieved coordinates\n  postal_coords <- data.frame()\n    \n  for (i in add_list){\n    #print(i)\n\n    r <- GET('https://www.onemap.gov.sg/api/common/elastic/search?',\n           query=list(searchVal=i,\n                     returnGeom='Y',\n                     getAddrDetails='Y'))\n    data <- fromJSON(rawToChar(r$content))\n    found <- data$found\n    res <- data$results\n    \n    # Create a new data frame for each address\n    new_row <- data.frame()\n    \n    # If single result, append \n    if (found == 1){\n      postal <- res$POSTAL \n      lat <- res$LATITUDE\n      lng <- res$LONGITUDE\n      new_row <- data.frame(address= i, \n                            postal = postal, \n                            latitude = lat, \n                            longitude = lng)\n    }\n    \n    # If multiple results, drop NIL and append top 1\n    else if (found > 1){\n      # Remove those with NIL as postal\n      res_sub <- res[res$POSTAL != \"NIL\", ]\n      \n      # Set as NA first if no Postal\n      if (nrow(res_sub) == 0) {\n          new_row <- data.frame(address= i, \n                                postal = NA, \n                                latitude = NA, \n                                longitude = NA)\n      }\n      \n      else{\n        top1 <- head(res_sub, n = 1)\n        postal <- top1$POSTAL \n        lat <- top1$LATITUDE\n        lng <- top1$LONGITUDE\n        new_row <- data.frame(address= i, \n                              postal = postal, \n                              latitude = lat, \n                              longitude = lng)\n      }\n    }\n\n    else {\n      new_row <- data.frame(address= i, \n                            postal = NA, \n                            latitude = NA, \n                            longitude = NA)\n    }\n    \n    # Add the row\n    postal_coords <- rbind(postal_coords, new_row)\n  }\n  return(postal_coords)\n}\n```\n:::\n\n\n\nWe then use the following code chunk to run the function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- get_coords(add_list)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(coords, \"data/rds/coords.rds\")\n```\n:::\n\n\n\n# Revising Hands-on Exercise\n\nWe load packages and include **tidymodels** for the in-class exercise.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, GWmodel, SpatialML, \n               tmap, rsample, Metrics, tidyverse, tidymodels, knitr, see, easystats)\n```\n:::\n\n\n\nWe load the rds file into `mdata`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmdata <- read_rds(\"data/rds/mdata.rds\")\n```\n:::\n\n\n\nWe use `initial_split()` to prepare the splits and then access the splits using `training()` and `testing()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (seed, kind = NULL, normal.kind = NULL, sample.kind = NULL) \n{\n    kinds <- c(\"Wichmann-Hill\", \"Marsaglia-Multicarry\", \"Super-Duper\", \n        \"Mersenne-Twister\", \"Knuth-TAOCP\", \"user-supplied\", \"Knuth-TAOCP-2002\", \n        \"L'Ecuyer-CMRG\", \"default\")\n    n.kinds <- c(\"Buggy Kinderman-Ramage\", \"Ahrens-Dieter\", \"Box-Muller\", \n        \"user-supplied\", \"Inversion\", \"Kinderman-Ramage\", \"default\")\n    s.kinds <- c(\"Rounding\", \"Rejection\", \"default\")\n    if (length(kind)) {\n        if (!is.character(kind) || length(kind) > 1L) \n            stop(\"'kind' must be a character string of length 1 (RNG to be used).\")\n        if (is.na(i.knd <- pmatch(kind, kinds) - 1L)) \n            stop(gettextf(\"'%s' is not a valid abbreviation of an RNG\", \n                kind), domain = NA)\n        if (i.knd == length(kinds) - 1L) \n            i.knd <- -1L\n    }\n    else i.knd <- NULL\n    if (!is.null(normal.kind)) {\n        if (!is.character(normal.kind) || length(normal.kind) != \n            1L) \n            stop(\"'normal.kind' must be a character string of length 1\")\n        normal.kind <- pmatch(normal.kind, n.kinds) - 1L\n        if (is.na(normal.kind)) \n            stop(gettextf(\"'%s' is not a valid choice\", normal.kind), \n                domain = NA)\n        if (normal.kind == 0L) \n            stop(\"buggy version of Kinderman-Ramage generator is not allowed\", \n                domain = NA)\n        if (normal.kind == length(n.kinds) - 1L) \n            normal.kind <- -1L\n    }\n    if (!is.null(sample.kind)) {\n        if (!is.character(sample.kind) || length(sample.kind) != \n            1L) \n            stop(\"'sample.kind' must be a character string of length 1\")\n        sample.kind <- pmatch(sample.kind, s.kinds) - 1L\n        if (is.na(sample.kind)) \n            stop(gettextf(\"'%s' is not a valid choice\", sample.kind), \n                domain = NA)\n        if (sample.kind == 0L) \n            warning(\"non-uniform 'Rounding' sampler used\", domain = NA)\n        if (sample.kind == length(s.kinds) - 1L) \n            sample.kind <- -1L\n    }\n    .Internal(set.seed(seed, i.knd, normal.kind, sample.kind))\n}\n<bytecode: 0x000002560052acc0>\n<environment: namespace:base>\n```\n\n\n:::\n\n```{.r .cell-code}\nresale_split <- initial_split(mdata,\n                              prop = 6.5/10)\ntrain_data <- training(resale_split)\ntest_data <- testing(resale_split)\n```\n:::\n\n\n\nWe can use `ggcorrmat()` to produce the correlation plot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmdata_nogeo <- mdata %>%\n  st_drop_geometry()\n\nggstatsplot::ggcorrmat(mdata_nogeo)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-13-1.png){width=1920}\n:::\n:::\n\n\n\n## Prediction using MLR\n\nWe can use `lm()` to produce the non-spatial multiple linear regression model. We then use **olsrr** package to produce a publication level report\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprice_mlr <- lm(resale_price ~ floor_area_sqm +\n                  storey_order + remaining_lease_mths +\n                  PROX_CBD + PROX_ELDERLYCARE + PROX_HAWKER +\n                  PROX_MRT + PROX_PARK + PROX_MALL + \n                  PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                  WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +\n                  WITHIN_1KM_PRISCH,\n                data=train_data)\n\nolsrr::ols_regress(price_mlr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                              Model Summary                                \n--------------------------------------------------------------------------\nR                           0.857       RMSE                    61241.154 \nR-Squared                   0.735       MSE                3755930224.018 \nAdj. R-Squared              0.734       Coef. Var                  14.137 \nPred R-Squared              0.734       AIC                    257198.078 \nMAE                     47287.918       SBC                    257313.971 \n--------------------------------------------------------------------------\n RMSE: Root Mean Square Error \n MSE: Mean Square Error \n MAE: Mean Absolute Error \n AIC: Akaike Information Criteria \n SBC: Schwarz Bayesian Criteria \n\n                                     ANOVA                                       \n--------------------------------------------------------------------------------\n                    Sum of                                                      \n                   Squares           DF       Mean Square       F          Sig. \n--------------------------------------------------------------------------------\nRegression    1.073265e+14           14      7.666177e+12    2041.086    0.0000 \nResidual       3.87612e+13        10320    3755930224.018                       \nTotal         1.460877e+14        10334                                         \n--------------------------------------------------------------------------------\n\n                                               Parameter Estimates                                                 \n------------------------------------------------------------------------------------------------------------------\n                   model          Beta    Std. Error    Std. Beta       t        Sig          lower         upper \n------------------------------------------------------------------------------------------------------------------\n             (Intercept)    106428.137     10719.139                   9.929    0.000     85416.547    127439.728 \n          floor_area_sqm      2781.241        90.565        0.166     30.710    0.000      2603.716      2958.767 \n            storey_order     13662.787       339.522        0.224     40.241    0.000     12997.258     14328.316 \n    remaining_lease_mths       345.606         4.589        0.449     75.306    0.000       336.610       354.602 \n                PROX_CBD    -17042.547       200.926       -0.593    -84.820    0.000    -17436.401    -16648.693 \n        PROX_ELDERLYCARE    -14388.896       994.879       -0.079    -14.463    0.000    -16339.052    -12438.740 \n             PROX_HAWKER    -20000.092      1267.512       -0.087    -15.779    0.000    -22484.662    -17515.522 \n                PROX_MRT    -31665.727      1732.322       -0.103    -18.279    0.000    -35061.414    -28270.039 \n               PROX_PARK     -5460.628      1475.918       -0.021     -3.700    0.000     -8353.713     -2567.543 \n               PROX_MALL    -13370.809      2014.963       -0.040     -6.636    0.000    -17320.526     -9421.091 \n        PROX_SUPERMARKET    -26867.912      4117.382       -0.036     -6.525    0.000    -34938.779    -18797.045 \nWITHIN_350M_KINDERGARTEN      8444.132       636.522        0.071     13.266    0.000      7196.425      9691.838 \n   WITHIN_350M_CHILDCARE     -4758.093       351.020       -0.080    -13.555    0.000     -5446.161     -4070.026 \n         WITHIN_350M_BUS      1091.322       220.861        0.027      4.941    0.000       658.392      1524.251 \n       WITHIN_1KM_PRISCH     -7757.364       484.342       -0.100    -16.016    0.000     -8706.767     -6807.960 \n------------------------------------------------------------------------------------------------------------------\n```\n\n\n:::\n:::\n\n\n\nAside from olsrr, we can also use the **performance** package to diagnose the model. The code chunk below checks for multicollinearity using the VIF. This is also in the easystats package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvif <- performance::check_collinearity(price_mlr)\nkable(vif,\n      caption = \"Variable Inflation Factor Results\") %>%\n  kable_styling(font_size = 18)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(vif) +\n  theme(axis.text.x = element_text(angle =45, hjust = 1))\n```\n:::\n\n\n\nCalculating adaptive bandwidth is done using `bw.gwr()` Note that the function can already work with sf format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_adaptive <- bw.gwr(resale_price ~ floor_area_sqm +\n                  storey_order + remaining_lease_mths +\n                  PROX_CBD + PROX_ELDERLYCARE + PROX_HAWKER +\n                  PROX_MRT + PROX_PARK + PROX_MALL + \n                  PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                  WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +\n                  WITHIN_1KM_PRISCH,\n                  data=train_data,\n                  approach=\"CV\",\n                  kernel=\"gaussian\",\n                  adaptive=TRUE,\n                  longlat=FALSE)\n```\n:::\n\n\n\nWe see that the recommended bandwidth is 41. We write the results into an RDS file so we do not need to rerun the code block.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(bw_adaptive, \"data/rds/bw_adaptive.rds\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 41\n```\n\n\n:::\n:::\n\n\n\nCalibrating the model is then done with the computed adaptive bandwidth through the `gwr.basic()` function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_adaptive <- gwr.basic(formula = resale_price ~\n                            floor_area_sqm + storey_order +\n                            remaining_lease_mths + PROX_CBD + \n                            PROX_ELDERLYCARE + PROX_HAWKER +\n                            PROX_MRT + PROX_PARK + PROX_MALL + \n                            PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                            WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +\n                            WITHIN_1KM_PRISCH,\n                          data=train_data,\n                          bw=bw_adaptive, \n                          kernel = 'gaussian', \n                          adaptive=TRUE,\n                          longlat = FALSE)\n```\n:::\n\n\n\nPredicting test data is done with the `gwr.predict()` function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_pred <- gwr.predict(formula = resale_price ~\n                          floor_area_sqm + storey_order +\n                          remaining_lease_mths + PROX_CBD + \n                          PROX_ELDERLYCARE + PROX_HAWKER + \n                          PROX_MRT + PROX_PARK + PROX_MALL + \n                          PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                          WITHIN_350M_CHILDCARE + WITHIN_350M_BUS + \n                          WITHIN_1KM_PRISCH, \n                        data=train_data, \n                        predictdata = test_data, \n                        bw=bw_adaptive, \n                        kernel = 'gaussian', \n                        adaptive=TRUE, \n                        longlat = FALSE,\n                        dMat1 = dmat_gwr)\n```\n:::\n\n\n\n## Prediction models with random forests\n\nSpatialML needs the coordinate information in order to perform training and predictions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- st_coordinates(mdata)\ncoords_train <- st_coordinates(train_data)\ncoords_test <- st_coordinates(test_data)\n```\n:::\n\n\n\nWe also need to remove the geometry from the datasets to ensure that they are simple dataframes and not sf dataframes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data_nogeom <- train_data %>% \n  st_drop_geometry()\n\ntest_data_nogeom <- test_data %>% \n  st_drop_geometry()\n```\n:::\n\n\n\nWe can calibrate the non-spatial model using `ranger()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nrf <- ranger(resale_price ~ floor_area_sqm + storey_order + \n               remaining_lease_mths + PROX_CBD + PROX_ELDERLYCARE + \n               PROX_HAWKER + PROX_MRT + PROX_PARK + PROX_MALL + \n               PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n               WITHIN_350M_CHILDCARE + WITHIN_350M_BUS + \n               WITHIN_1KM_PRISCH,\n             data=train_data_nogeom)\nrf\n```\n:::\n\n\n\nWe can calibrate the spatial model using `grf()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\ngwRF_adaptive <- grf(formula = resale_price ~ floor_area_sqm + storey_order +\n                       remaining_lease_mths + PROX_CBD + PROX_ELDERLYCARE +\n                       PROX_HAWKER + PROX_MRT + PROX_PARK + PROX_MALL +\n                       PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                       WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +\n                       WITHIN_1KM_PRISCH,\n                     dframe=train_data_nogeom, \n                     bw=bw_adaptive,\n                     kernel=\"adaptive\",\n                     coords=coords_train)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(gwRF_adaptive, \"data/rds/gwRF_adaptive.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nPredicting test data values first needs including the coordinates into the test data set before passing it into `predict.grf()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data_nogeom <- cbind(test_data_nogeom, coords_test)\n\ngwRF_pred <- predict.grf(gwRF_adaptive, \n                           test_data_nogeom, \n                           x.var.name=\"X\",\n                           y.var.name=\"Y\", \n                           local.w=1,\n                           global.w=0)\n```\n:::\n\n\n\nThe returned object is a list. We convert it into a dataframe to be able to work with it for visualizations and calculations. We then combine it with the original dataset\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGRF_pred_df <- as.data.frame(gwRF_pred)\n\ntest_data_p <- cbind(test_data_nogeom, GRF_pred_df)\n```\n:::\n\n\n\nWe can then compute the RMSE and plot the actual and predicted values.\n",
    "supporting": [
      "In-class_Ex07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}